<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Clash Royale</title>
    <style>
        /* --- CORE LAYOUT & NO SCROLL --- */
        * { box-sizing: border-box; }
        html, body {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            background-color: #1a1a1a;
            background-image: radial-gradient(#2a2a2a 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: hidden; /* STRICTLY NO SCROLL */
            display: flex; justify-content: center; align-items: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* Prevents mobile pull-to-refresh */
            user-select: none;
        }

        #game-wrapper {
            position: relative;
            background: #000;
            border: 4px solid #333;
            border-radius: 4px;
            box-shadow: 0 0 50px rgba(0,0,0,1);
            overflow: hidden;
            /* Dimensions set by JS to perfectly fit screen */
            width: 0px; height: 0px; 
        }

        canvas { display: block; width: 100%; height: 100%; background: #4c9b56; }
        
        .full-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; /* Allow clicks to pass through empty areas */
            display: flex; flex-direction: column; 
        }

        /* --- MENU LAYOUT --- */
        #menu-layer { background: linear-gradient(135deg, #3b607d, #2a4055); pointer-events: auto; z-index: 200; }
        .top-bar {
            width: 100%; height: 8%; background: rgba(0,0,0,0.3);
            display: flex; justify-content: center; align-items: center; 
            padding: 0 20px; color: white; font-weight: bold; font-size: 18px; 
            text-shadow: 1px 1px 0 #000;
        }
        .trophy-display { display: flex; align-items: center; gap: 8px; background: rgba(0,0,0,0.5); padding: 5px 15px; border-radius: 20px; border: 1px solid #aaa; }
        .trophy-icon { width: 24px; height: 24px; fill: #ffd700; drop-shadow: 0 2px 2px rgba(0,0,0,0.5); }

        #view-container { flex-grow: 1; position: relative; width: 100%; overflow: hidden; }
        .view { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; align-items: center; }
        .view.active { display: flex; }

        /* BATTLE MENU */
        .arena-graphic { flex-grow: 1; width: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background: url('data:image/svg+xml;utf8,<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><rect width="100" height="100" fill="%234c9b56" opacity="0.3"/></svg>'); }
        #arena-title { font-size: 24px; color: #fff; text-shadow: 0 2px 0 #000; margin-bottom: 20px; font-weight: 900; text-transform: uppercase; }
        
        .battle-btn { 
            width: 180px; height: 80px; 
            background: linear-gradient(to bottom, #ffeb3b, #fbc02d); 
            border: 3px solid #fff; border-radius: 12px; 
            box-shadow: 0 6px 0 #f57f17, 0 10px 10px rgba(0,0,0,0.3); 
            display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 10px;
            cursor: pointer; margin-bottom: 30px; pointer-events: auto; 
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .battle-btn:active { transform: translateY(4px); box-shadow: 0 2px 0 #f57f17; }
        .battle-text { font-size: 28px; font-weight: 900; color: #5d4037; text-transform: uppercase; -webkit-text-stroke: 1px #fff; letter-spacing: 1px; }
        .battle-icon { width: 32px; height: 32px; fill: #5d4037; stroke: #fff; stroke-width: 1px; }
        
        .diff-container { display: flex; gap: 15px; margin-top: 10px; pointer-events: auto; }
        .diff-btn { 
            padding: 8px 12px; 
            border: 2px solid #aaa; border-radius: 8px; 
            background: #444; color: #ccc; 
            font-weight: bold; cursor: pointer; font-size: 12px; 
            display: flex; flex-direction: column; align-items: center; gap: 2px;
            min-width: 70px;
            box-shadow: 0 3px 0 #222;
        }
        .diff-btn svg { width: 14px; height: 14px; fill: #666; }
        .diff-btn.active { background: #3c9; color: white; border-color: #fff; box-shadow: 0 3px 0 #063; transform: scale(1.05); }
        .diff-btn.active svg { fill: #ffeb3b; filter: drop-shadow(0 0 2px orange); }

        /* DECK MENU */
        #deck-view { background: #2a3a4a; padding: 10px; overflow-y: auto; }
        .deck-header { width: 100%; color: #fff; text-shadow: 1px 1px 0 #000; margin-bottom: 5px; font-weight: 800; font-size: 14px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #555; padding-bottom: 5px; }
        .deck-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; width: 100%; margin-bottom: 20px; padding: 5px; }
        #sort-select { background: #444; color: white; border: 1px solid #777; border-radius: 4px; padding: 2px 5px; font-size: 11px; cursor: pointer; }

        /* MENU CARDS */
        .real-card { width: 100%; aspect-ratio: 3/4; border-radius: 6px; position: relative; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: flex-end; box-shadow: 0 4px 6px rgba(0,0,0,0.6); overflow: visible; }
        .real-card.selected { transform: translateY(-5px); box-shadow: 0 0 15px #0f0; z-index: 10; }
        .real-card.common { background: radial-gradient(circle at center, #9ebdd6 40%, #5e7fa0 100%); border: 3px solid #5e7fa0; border-bottom: 6px solid #4a6a8a; }
        .real-card.rare { background: radial-gradient(circle at center, #ffdfaa 40%, #d68a29 100%); border: 3px solid #dba02c; border-bottom: 6px solid #b37e1e; }
        .real-card.epic { background: radial-gradient(circle at center, #d980fa 40%, #8708c0 100%); border: 3px solid #b636d6; border-bottom: 6px solid #8616a6; }
        .real-card.legendary { background: radial-gradient(circle at center, #4ff 20%, #d5f 100%); border: 3px solid #4ff; border-bottom: 6px solid #2cc; animation: legendGlow 3s infinite; }
        @keyframes legendGlow { 0% { box-shadow: 0 0 5px #4ff; } 50% { box-shadow: 0 0 15px #d5f; } 100% { box-shadow: 0 0 5px #4ff; } }
        .real-card img { position: absolute; top: 5%; left: 5%; width: 90%; height: 75%; object-fit: contain; filter: drop-shadow(0px 5px 3px rgba(0,0,0,0.5)); z-index: 1; pointer-events: none; }
        .elixir-drop { position: absolute; top: -5px; left: -5px; width: 22px; height: 22px; background: radial-gradient(circle at 35% 35%, #f5abff, #b029ff, #570080); border: 1px solid #30004a; box-shadow: 2px 3px 5px rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; font-family: 'Arial Black', sans-serif; font-size: 12px; color: white; text-shadow: 1px 1px 0 #000; z-index: 5; border-top-left-radius: 50%; border-top-right-radius: 50%; border-bottom-left-radius: 50%; border-bottom-right-radius: 5%; transform: rotate(45deg); }
        .elixir-drop span { transform: rotate(-45deg); margin-top: 2px; margin-left: 2px; }
        
        .card-name-tag { position: relative; width: 105%; text-align: center; font-family: 'Arial Black', sans-serif; font-size: 7px; color: #fff; text-shadow: 1px 1px 0 #000; margin-bottom: 4px; z-index: 3; letter-spacing: 0.5px; }

        .bottom-tabs { width: 100%; height: 9%; background: #222; display: flex; justify-content: space-evenly; align-items: center; border-top: 2px solid #444; pointer-events: auto; }
        .tab { width: 60px; height: 40px; background: #444; border-radius: 5px; display: flex; justify-content: center; align-items: center; cursor: pointer; color: #888; transition: all 0.1s; }
        .tab.active { background: #ffe040; color: #530; border: 2px solid #fff; transform: translateY(-5px); box-shadow: 0 5px 10px rgba(0,0,0,0.5); }
        .tab-icon { width: 28px; height: 28px; fill: currentColor; }

        /* --- GAME HUD & DOCK LAYOUT --- */
        #game-ui-layer { 
            justify-content: space-between; /* Pushes HUD to top, Dock to bottom */
            z-index: 100; 
            display: none; 
        }

        #top-hud { 
            width: 100%; height: 10%; 
            display: flex; justify-content: center; align-items: center; 
            position: relative; pointer-events: none;
        }
        
        #timer-box { 
            position: absolute; left: 15px; top: 15px; 
            background: rgba(0,0,0,0.6); color: white; padding: 5px 15px; 
            border-radius: 20px; font-weight: bold; font-size: 18px; 
            border: 2px solid #444; display: flex; flex-direction: column; align-items: center; 
            font-family: 'Arial Black', sans-serif; pointer-events: auto; 
        }
        
        #game-status { 
            font-size: 24px; color: #ffeb3b; text-transform: uppercase; 
            position: absolute; top: 20%; width: 100%; text-align: center;
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #000; font-weight: 900; 
            z-index: 500; display: none; animation: popIn 0.5s ease-out; 
        }
        @keyframes popIn { 0% { transform: scale(0); opacity: 0; } 70% { transform: scale(1.2); opacity: 1; } 100% { transform: scale(1); opacity: 1; } }

        #home-btn { 
            position: absolute; right: 15px; top: 15px; 
            width: 40px; height: 40px; background: #d32f2f; 
            border: 2px solid #fff; border-radius: 8px; color: white; 
            display: flex; justify-content: center; align-items: center; 
            cursor: pointer; pointer-events: auto; box-shadow: 0 4px 0 #8b0000; 
        }
        #home-btn svg { width: 24px; height: 24px; fill: white; filter: drop-shadow(1px 1px 0 black); }
        #home-btn:active { transform: translateY(4px); box-shadow: none; }

        /* --- REDESIGNED BOTTOM DOCK --- */
        #bottom-dock-container { 
            width: 100%; 
            display: flex; flex-direction: column; align-items: center; 
            pointer-events: none; /* Allows clicks on canvas behind empty spaces */
            padding-bottom: 2px;
        }

        #elixir-container { 
            width: 95%; height: 28px; 
            background: #111; 
            margin-bottom: 5px; 
            border-radius: 14px; 
            border: 3px solid #000; 
            position: relative; 
            box-shadow: 0 4px 10px rgba(0,0,0,0.8); 
            overflow: hidden; 
            z-index: 1001; /* ALWAYS ON TOP */
            pointer-events: auto;
        }
        
        #elixir-fill { 
            height: 100%; width: 50%; 
            background: linear-gradient(180deg, #d56aff, #7600bc); 
            transition: width 0.1s linear; 
            box-shadow: inset 0 2px 5px rgba(255,255,255,0.4);
        }
        
        #elixir-text { 
            position: absolute; right: 15px; top: 0; 
            color: #fff; font-weight: 900; line-height: 24px; 
            font-family: 'Arial Black', sans-serif; font-size: 16px;
            text-shadow: 0 0 4px #d0f;
        }

        #card-dock { 
            width: 100%; height: 110px; 
            background: url('data:image/svg+xml;utf8,<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg"><rect width="100" height="100" fill="%234a3020"/><path d="M0 0 L100 100 M100 0 L0 100" stroke="%233a2010" stroke-width="2"/></svg>'); 
            background-size: 20px 20px; 
            border-top: 4px solid #2a1a10; 
            display: flex; justify-content: space-evenly; align-items: center; 
            pointer-events: auto; /* Re-enable clicks */
            box-shadow: 0 -5px 15px rgba(0,0,0,0.5);
        }

        .game-card { width: 19%; aspect-ratio: 3/4; border-radius: 6px; position: relative; cursor: grab; overflow: hidden; box-shadow: 0 4px 5px rgba(0,0,0,0.5); transition: transform 0.1s; display: block; background: #222; }
        .game-card.active { transform: translateY(-20px) scale(1.1); border-color: #ffff00; box-shadow: 0 10px 20px rgba(0,0,0,0.8), 0 0 10px #ffff00; z-index: 500; }
        .game-card.disabled { filter: grayscale(100%) brightness(0.6); cursor: not-allowed; }
        
        .game-card.common { background: linear-gradient(135deg, #6b9ac4, #3b6a94); border: 2px solid #4a7a9a; }
        .game-card.rare 	{ background: linear-gradient(135deg, #f09e38, #c06e08); border: 2px solid #d07e18; }
        .game-card.epic 	{ background: linear-gradient(135deg, #b738f0, #8708c0); border: 2px solid #9718d0; }
        .game-card.legendary { background: linear-gradient(135deg, #4ff, #d5f); border: 2px solid #4ff; }
        
        .game-card img { position: absolute; top: 15%; left: 5%; width: 90%; height: 80%; object-fit: contain; z-index:1; pointer-events: none; }
        
        /* Updated: Elixir Cost Z-Index increased to sit above name */
        .game-card .cost { position: absolute; top: -5px; left: -5px; width: 22px; height: 22px; background: #d0f; color: white; border-radius: 50%; border: 2px solid white; display: flex; justify-content: center; align-items: center; font-weight: bold; font-size: 12px; z-index: 20; box-shadow: 1px 1px 3px rgba(0,0,0,0.5); }
        
        /* UPDATED: Name anchored to TOP */
        .game-card-name { 
            position: absolute; 
            top: 0; /* Moved to top */
            left: 0; 
            width: 100%; 
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), rgba(0,0,0,0.5)); 
            color: white; 
            font-size: 9px; 
            font-weight: bold; 
            text-align: right; /* Align right to avoid elixir bubble */
            padding-right: 4px;
            padding-top: 2px;
            white-space: nowrap; 
            overflow: hidden; 
            z-index: 10; 
            text-shadow: 1px 1px 0 #000;
        }
        
        #end-screen { display: none; background: rgba(0,0,0,0.85); z-index: 300; pointer-events: auto; align-items: center; justify-content: center; flex-direction: column; }
        
        /* OK Button on end screen */
        .ok-btn {
            padding: 10px 30px; 
            background: #3c9; 
            border: 3px solid #fff; 
            border-radius: 20px; 
            color: white; 
            font-weight: bold; 
            font-size: 20px; 
            cursor: pointer; 
            display: flex; align-items: center; gap: 10px;
            box-shadow: 0 4px 0 #063;
        }
        .ok-btn:active { transform: translateY(4px); box-shadow: none; }
    </style>
</head>
<body>

<div id="game-wrapper">
    <div id="menu-layer" class="full-layer">
        <div class="top-bar">
            <div class="trophy-display">
                <svg class="trophy-icon" viewBox="0 0 24 24">
                    <path d="M20.2 2H3.8C2.8 2 2 2.8 2 3.8V5c0 2.2 1.8 4 4 4h.2c.5 1.5 1.7 2.8 3.3 3.4 0 .1-.1.2-.1.3-.2.6-.4 1.2-.4 1.8 0 1.1.9 2 2 2h2c1.1 0 2-.9 2-2 0-.6-.2-1.2-.4-1.8 0-.1-.1-.2-.1-.3 1.6-.6 2.8-1.9 3.3-3.4h.2c2.2 0 4-1.8 4-4V3.8c0-1-1-1.8-2-1.8zM6 7c-1.1 0-2-.9-2-2V4h2v3zm9 7.5c0 .3-.2.5-.5.5h-5c-.3 0-.5-.2-.5-.5s.2-.5.5-.5h5c.3 0 .5.2.5.5zM18 7h2V4h-2v3z"/>
                </svg>
                <span id="trophy-count">0</span>
            </div>
        </div>
        <div id="view-container">
            <div id="battle-view" class="view active">
                <div class="arena-graphic">
                    <div id="arena-title">Training Camp</div>
                    
                    <div class="battle-btn" onclick="startGame()">
                        <svg class="battle-icon" viewBox="0 0 24 24">
                            <path d="M19.7 3.3c-.4-.4-1-.4-1.4 0l-1.6 1.6-4.3-1.1c-.3-.1-.6 0-.8.2l-2 2 4.2 4.2-7 7-2.8-2.8c-.4-.4-1-.4-1.4 0-.4.4-.4 1 0 1.4l3.5 3.5c.2.2.5.3.7.3s.5-.1.7-.3l3.5-3.5c.4-.4.4-1 0-1.4l-2.8-2.8 7-7 4.2 4.2 2-2c.2-.2.3-.6.2-.8l-1.1-4.3 1.6-1.6c.4-.4.4-1.1 0-1.5z"/>
                        </svg>
                        <div class="battle-text">Battle</div>
                    </div>
                    
                    <div style="color:#aaa; font-size:12px; font-weight:bold; margin-bottom:5px;">DIFFICULTY</div>
                    
                    <div class="diff-container">
                        <div id="btn-easy" class="diff-btn" onclick="setDifficulty('easy')">
                            <span>Easy</span>
                            <div style="display:flex">
                                <svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>
                            </div>
                        </div>
                        <div id="btn-medium" class="diff-btn active" onclick="setDifficulty('medium')">
                            <span>Medium</span>
                            <div style="display:flex">
                                <svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>
                                <svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>
                            </div>
                        </div>
                        <div id="btn-hard" class="diff-btn" onclick="setDifficulty('hard')">
                            <span>Hard</span>
                            <div style="display:flex">
                                <svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>
                                <svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>
                                <svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div id="deck-view" class="view">
                <div class="deck-header">
                    <span>Battle Deck</span>
                    <span id="avg-elixir" style="font-size: 10px; font-weight: normal; color: #ccc;">Avg: 3.5</span>
                </div>
                <div id="deck-grid" class="deck-grid"></div>
                <div style="height: 2px; background: #555; width: 100%; margin: 10px 0;"></div>
                <div class="deck-header">
                    <span>Card Collection</span>
                    <select id="sort-select" onchange="sortAndRender()">
                        <option value="elixir">By Elixir</option>
                        <option value="rarity">By Rarity</option>
                        <option value="name">By Name</option>
                    </select>
                </div>
                <div id="collection-grid" class="deck-grid"></div>
            </div>
        </div>
        <div class="bottom-tabs">
            <div class="tab" onclick="switchTab('deck', this)">
                <svg class="tab-icon" viewBox="0 0 24 24">
                    <path d="M4 2h10v16H4zm2 2v12h6V4zm6 16h8V4h-2v14H12z"/>
                </svg>
            </div>
            <div class="tab active" onclick="switchTab('battle', this)">
                <svg class="tab-icon" viewBox="0 0 24 24">
                   <path d="M14.5 4.5L10 9l-5.5-2L2 9.5 7.5 15l2-2 3.5 3.5-1 4 5-2 3.5 3.5L22 20.5l-1.5-1.5-3.5-3.5 2-5-4 1-3.5-3.5 2-2z"/>
                </svg>
            </div>
        </div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="game-ui-layer" class="full-layer">
        <div id="top-hud">
            <div id="timer-box"><span id="time-display">3:00</span></div>
            <div id="home-btn" onclick="returnToMenu()">
                <svg viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>
            </div>
        </div>
        <div id="game-status"></div>
        <div id="bottom-dock-container">
            <div id="elixir-container"><div id="elixir-fill"></div><div id="elixir-text">5</div></div>
            <div id="card-dock"></div>
        </div>
    </div>
    <div id="end-screen" class="full-layer">
        <h1 id="end-msg" style="font-size: 40px; color: #ffcc00; -webkit-text-stroke: 2px black; margin:10px;">WINNER</h1>
        <h2 id="trophy-change" style="font-size: 24px; color: #fff; margin-bottom:20px;">+30 ??</h2>
        <button class="ok-btn" onclick="returnToMenu()">
            <svg viewBox="0 0 24 24" style="width:24px;height:24px;fill:white;"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>
            <span>OK</span>
        </button>
    </div>
</div>

<script>
const SPRITES = {};
function createAsset(name, svgContent) {
    const header = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">`;
    const blob = new Blob([header + svgContent + `</svg>`], {type: 'image/svg+xml'});
    const img = new Image();
    img.src = URL.createObjectURL(blob);
    SPRITES[name] = img;
}

// ASSETS
createAsset('knight', `<rect x="22" y="35" width="56" height="45" rx="8" fill="#9aa" stroke="#222" stroke-width="3"/><circle cx="50" cy="38" r="22" fill="#cfcfcf" stroke="#222" stroke-width="3"/><rect x="45" y="10" width="10" height="20" fill="#c00"/><circle cx="42" cy="36" r="3" fill="#000"/><circle cx="58" cy="36" r="3" fill="#000"/><path d="M40 45 Q50 50 60 45" stroke="#000" stroke-width="2" fill="none"/>`);
createAsset('archer', `<circle cx="50" cy="40" r="22" fill="#fec" stroke="#222" stroke-width="3"/><path d="M18 42 Q50 5 82 42 L70 85 Q50 95 30 85 Z" fill="#f06"/><circle cx="42" cy="38" r="3" fill="#000"/><circle cx="58" cy="38" r="3" fill="#000"/><path d="M10 55 Q50 100 90 55" fill="none" stroke="#630" stroke-width="4"/><line x1="12" y1="55" x2="88" y2="55" stroke="#fff" stroke-width="1"/>`);
createAsset('giant', `<rect x="18" y="40" width="64" height="45" rx="10" fill="#b87" stroke="#222" stroke-width="3"/><circle cx="50" cy="30" r="20" fill="#fca" stroke="#222" stroke-width="3"/><circle cx="44" cy="28" r="3" fill="#000"/><circle cx="56" cy="28" r="3" fill="#000"/><path d="M42 36 Q50 42 58 36" stroke="#000" stroke-width="2" fill="none"/>`);
createAsset('pekka', `<path d="M20 25 L35 10 L50 22 L65 10 L80 25 L75 85 L25 85 Z" fill="#334" stroke="#111" stroke-width="3"/><circle cx="42" cy="45" r="4" fill="#0ff"/><circle cx="58" cy="45" r="4" fill="#0ff"/><path d="M15 30 L30 45 M85 30 L70 45" stroke="#556" stroke-width="4"/>`);
createAsset('minipekka', `<rect x="25" y="30" width="50" height="50" rx="6" fill="#556" stroke="#111" stroke-width="3"/><circle cx="50" cy="45" r="6" fill="#0ff"/><rect x="18" y="45" width="10" height="35" fill="#778"/><rect x="72" y="45" width="10" height="35" fill="#778"/>`);
createAsset('musketeer', `<circle cx="50" cy="42" r="22" fill="#fec" stroke="#222" stroke-width="3"/><path d="M25 42 Q50 10 75 42 Z" fill="#445"/><circle cx="44" cy="40" r="3" fill="#000"/><circle cx="56" cy="40" r="3" fill="#000"/><rect x="60" y="45" width="28" height="8" fill="#532"/>`);
createAsset('wizard', `<circle cx="50" cy="38" r="20" fill="#fec" stroke="#222" stroke-width="3"/><path d="M22 38 L50 5 L78 38 Z" fill="#33f"/><path d="M30 85 L70 85 L50 30 Z" fill="#33f"/><circle cx="60" cy="48" r="8" fill="#fa0"/>`);
createAsset('dragon', `<circle cx="50" cy="35" r="20" fill="#6d6" stroke="#222" stroke-width="3"/><path d="M20 55 Q50 75 80 55 L60 85 L40 85 Z" fill="#6d6"/><circle cx="45" cy="33" r="3" fill="#000"/><circle cx="55" cy="33" r="3" fill="#000"/>`);
createAsset('skeletons', `<circle cx="30" cy="45" r="10" fill="#eee" stroke="#000" stroke-width="2"/><circle cx="70" cy="45" r="10" fill="#eee" stroke="#000" stroke-width="2"/><circle cx="50" cy="72" r="12" fill="#eee" stroke="#000" stroke-width="2"/>`);
createAsset('arrow', `<line x1="10" y1="50" x2="80" y2="50" stroke="#532" stroke-width="4"/><path d="M80 50 L65 40 L65 60 Z" fill="#eee"/>`);
createAsset('valkyrie', `<circle cx="50" cy="38" r="20" fill="#fec"/><path d="M30 85 L70 85 L60 30 L40 30 Z" fill="#c63"/><path d="M20 55 Q50 70 80 55" stroke="#963" stroke-width="6"/>`);
createAsset('hog', `<ellipse cx="50" cy="55" rx="30" ry="20" fill="#d9a"/><circle cx="40" cy="48" r="4" fill="#000"/><circle cx="60" cy="48" r="4" fill="#000"/>`);
createAsset('balloon', `<ellipse cx="50" cy="30" rx="22" ry="26" fill="#333"/><rect x="40" y="55" width="20" height="20" fill="#754"/>`);
createAsset('prince', `<circle cx="50" cy="35" r="18" fill="#fec"/><path d="M35 10 L65 10 L55 35 L45 35 Z" fill="#fc0"/>`);
createAsset('darkprince', `<circle cx="50" cy="35" r="18" fill="#bbb"/><path d="M35 10 L65 10 L55 35 L45 35 Z" fill="#333"/><path d="M25 60 Q50 75 75 60" stroke="#444" stroke-width="6"/>`);
createAsset('bomber', `<circle cx="50" cy="38" r="18" fill="#eee"/><circle cx="50" cy="65" r="10" fill="#333"/>`);
createAsset('icewizard', `<circle cx="50" cy="38" r="20" fill="#def"/><path d="M22 38 L50 5 L78 38 Z" fill="#6cf"/><circle cx="60" cy="48" r="8" fill="#9ff"/>`);
createAsset('firecracker', `<circle cx="50" cy="38" r="18" fill="#fec"/><rect x="60" y="50" width="20" height="6" fill="#900"/><line x1="80" y1="53" x2="95" y2="53" stroke="#fa0" stroke-width="2"/>`);
createAsset('barbarians', `<circle cx="30" cy="45" r="14" fill="#fec"/><circle cx="70" cy="45" r="14" fill="#fec"/><path d="M20 75 L40 75" stroke="#963" stroke-width="6"/><path d="M60 75 L80 75" stroke="#963" stroke-width="6"/>`);
createAsset('minions', `<circle cx="40" cy="40" r="12" fill="#55f"/><circle cx="60" cy="40" r="12" fill="#55f"/><path d="M30 50 L40 70 L50 50 Z" fill="#88f"/><path d="M70 50 L60 70 L50 50 Z" fill="#88f"/>`);
createAsset('goblins', `<circle cx="30" cy="30" r="15" fill="#4d4" stroke="#050"/><circle cx="70" cy="30" r="15" fill="#4d4" stroke="#050"/><circle cx="50" cy="70" r="18" fill="#4d4" stroke="#050"/><path d="M45 75 L55 75" stroke="#000" stroke-width="2"/>`);
createAsset('witch', `<circle cx="50" cy="35" r="20" fill="#d9f"/><path d="M20 85 L50 35 L80 85" fill="#537"/><circle cx="40" cy="35" r="3" fill="#f0f"/><circle cx="60" cy="35" r="3" fill="#f0f"/>`);
createAsset('megaknight', `<rect x="20" y="20" width="60" height="60" rx="10" fill="#333"/><circle cx="50" cy="35" r="15" fill="#222" stroke="#000"/><rect x="15" y="45" width="20" height="40" fill="#222"/><rect x="65" y="45" width="20" height="40" fill="#222"/>`);
createAsset('golem', `<path d="M30 80 L50 20 L70 80" fill="#876"/><circle cx="50" cy="30" r="15" fill="#a98"/><rect x="20" y="40" width="20" height="40" fill="#654"/><rect x="60" y="40" width="20" height="40" fill="#654"/>`);
createAsset('threem', `<circle cx="30" cy="40" r="12" fill="#fec"/><circle cx="50" cy="60" r="12" fill="#fec"/><circle cx="70" cy="40" r="12" fill="#fec"/>`);
createAsset('leon', `<rect x="30" y="30" width="40" height="50" fill="#4a4"/><circle cx="50" cy="30" r="15" fill="#dca"/><rect x="20" y="40" width="10" height="30" fill="#dca"/><rect x="70" y="40" width="10" height="30" fill="#dca"/><line x1="30" y1="80" x2="30" y2="95" stroke="#333" stroke-width="5"/><line x1="70" y1="80" x2="70" y2="95" stroke="#333" stroke-width="5"/>`);
// GOBLIN CARDS
createAsset('speargoblins', `<circle cx="30" cy="30" r="15" fill="#4d4" stroke="#050"/><circle cx="70" cy="30" r="15" fill="#4d4" stroke="#050"/><circle cx="50" cy="70" r="18" fill="#4d4" stroke="#050"/><path d="M48 20 L52 20 L52 80 L48 80 Z" fill="#630"/><path d="M28 10 L32 10 L32 50 L28 50 Z" fill="#630"/><path d="M68 10 L72 10 L72 50 L68 50 Z" fill="#630"/>`);
createAsset('dartgoblin', `<circle cx="50" cy="40" r="20" fill="#4d4"/><path d="M30 20 L70 20 L60 50 L40 50 Z" fill="#222"/><rect x="45" y="40" width="10" height="30" fill="#853"/>`);
createAsset('goblingiant', `<rect x="20" y="30" width="60" height="60" rx="10" fill="#4d4" stroke="#050" stroke-width="3"/><circle cx="50" cy="20" r="15" fill="#4d4"/><circle cx="30" cy="15" r="8" fill="#4d4"/><circle cx="70" cy="15" r="8" fill="#4d4"/>`);
createAsset('goblinbarrel', `<rect x="30" y="20" width="40" height="60" rx="10" fill="#630" stroke="#000"/><line x1="30" y1="35" x2="70" y2="35" stroke="#000"/><line x1="30" y1="65" x2="70" y2="65" stroke="#000"/>`);
// SPELL ASSETS
createAsset('fireball', `<circle cx="50" cy="50" r="30" fill="#f90"/><path d="M50 20 L65 50 L50 80 L35 50 Z" fill="#f00"/><path d="M50 50 L70 50 L50 30 Z" fill="#ff0"/>`);
createAsset('zap', `<circle cx="50" cy="50" r="25" fill="#6cc"/><path d="M40 30 L60 70 M60 30 L40 70" stroke="#00f" stroke-width="5"/>`);
createAsset('rocket', `<rect x="35" y="10" width="30" height="80" fill="#c00"/><path d="M50 10 L30 30 L70 30 Z" fill="#fcc"/><circle cx="50" cy="90" r="10" fill="#fa0"/>`);
// BUILDING ASSETS
createAsset('building', `<rect x="30" y="30" width="40" height="50" fill="#864" stroke="#310" stroke-width="3"/><rect x="40" y="40" width="20" height="10" fill="#d9a"/>`);
createAsset('goblinhut', `<rect x="30" y="30" width="40" height="50" fill="#4d4" stroke="#050" stroke-width="3"/><rect x="40" y="40" width="20" height="10" fill="#fff"/><path d="M30 30 L50 10 L70 30 Z" fill="#630"/>`);
createAsset('bombtower', `<rect x="30" y="30" width="40" height="50" fill="#999" stroke="#333" stroke-width="3"/><rect x="40" y="40" width="20" height="10" fill="#333"/><rect x="45" y="20" width="10" height="10" fill="#f00"/>`);


const CANVAS = document.getElementById('gameCanvas');
const CTX = CANVAS.getContext('2d');
// Internal resolution (coordinate system)
const GAME_W = 540;
const GAME_H = 960;
CANVAS.width = GAME_W; CANVAS.height = GAME_H;
const TILE = 30;

const CONSTANTS = {
    LANE_LEFT: 4 * TILE, LANE_RIGHT: 14 * TILE, RIVER_Y: 400, BRIDGE_Y: 400, BASE_DEPLOY: 440,
    DOCK_Y: 820, POCKET_Y: 215, 
    CENTER_X: 540 / 2, TILE_SIZE: TILE,
    GAME_DURATION: 180, 
};

// 30 CARDS 
const CARDS = {
    knight: { name: "Knight", cost: 3, rarity: 'common', type: 'troop', hp: 1766, dmg: 202, spd: 50, hit: 1.2, count: 1, targetPref: 'any', sprite: 'knight', rng: 1.2 * TILE, sight: 5.5*TILE, targetsAir: false },
    archer: { name: "Archers", cost: 3, rarity: 'common', type: 'troop', hp: 304, dmg: 107, spd: 55, hit: 0.9, count: 2, targetPref: 'any', sprite: 'archer', rng: 5.0 * TILE, sight: 5.5*TILE, targetsAir: true },
    giant:	{ name: "Giant", cost: 5, rarity: 'rare', type: 'troop', hp: 4091, dmg: 254, spd: 35, hit: 1.5, count: 1, targetPref: 'building', sprite: 'giant', rng: 1.2 * TILE, sight: 7.5*TILE, targetsAir: false },
    pekka:	{ name: "Pekka", cost: 7, rarity: 'epic', type: 'troop', hp: 3760, dmg: 816, spd: 35, hit: 1.8, count: 1, targetPref: 'any', sprite: 'pekka', rng: 1.6 * TILE, sight: 5.0*TILE, targetsAir: false },
    minipekka: { name: "Mini Pekka", cost: 4, rarity: 'rare', type: 'troop', hp: 1361, dmg: 720, spd: 80, hit: 1.6, count: 1, targetPref: 'any', sprite: 'minipekka', rng: 1.2 * TILE, sight: 5.5*TILE, targetsAir: false },
    musketeer: { name: "Musketeer", cost: 4, rarity: 'rare', type: 'troop', hp: 720, dmg: 218, spd: 55, hit: 1.0, count: 1, targetPref: 'any', sprite: 'musketeer', rng: 6.0 * TILE, sight: 6.0*TILE, targetsAir: true },
    goblins:	{ name: "Goblins", cost: 2, rarity: 'common', type: 'troop', hp: 202, dmg: 120, spd: 100, hit: 1.1, count: 3, targetPref: 'any', sprite: 'goblins', rng: 0.8 * TILE, sight: 5.5*TILE, targetsAir: false },
    dragon:	{ name: "Baby Dragon", cost: 4, rarity: 'epic', type: 'troop', hp: 1152, dmg: 160, spd: 75, hit: 1.5, count: 1, targetPref: 'any', sprite: 'dragon', rng: 3.5 * TILE, sight: 5.5*TILE, flying: true, targetsAir: true, splash: true, splashRadius: 2.5*TILE },
    wizard:	{ name: "Wizard", cost: 5, rarity: 'rare', type: 'troop', hp: 720, dmg: 281, spd: 55, hit: 1.4, count: 1, targetPref: 'any', sprite: 'wizard', rng: 5.5 * TILE, sight: 5.5*TILE, targetsAir: true, splash: true, splashRadius: 2.0*TILE },
    skeletons: { name: "Skeletons", cost: 1, rarity: 'common', type: 'troop', hp: 81, dmg: 81, spd: 80, hit: 1.0, count: 3, targetPref: 'any', sprite: 'skeletons', rng: 0.5 * TILE, sight: 5.5*TILE, targetsAir: false },
    valkyrie: { name: "Valkyrie", cost: 4, rarity: 'rare', type: 'troop', hp: 1908, dmg: 267, spd: 55, hit: 1.5, count: 1, targetPref: 'any', sprite: 'valkyrie', rng: 1.5 * TILE, sight: 5.5*TILE, targetsAir: false, splash: true, splashRadius: 2.0*TILE },
    hog: { name: "Hog Rider", cost: 4, rarity: 'rare', type: 'troop', hp: 1696, dmg: 318, spd: 100, hit: 1.6, count: 1, targetPref: 'building', sprite: 'hog', rng: 1.2 * TILE, sight: 9.5*TILE, targetsAir: false },
    balloon: { name: "Balloon", cost: 5, rarity: 'epic', type: 'troop', hp: 1680, dmg: 960, spd: 55, hit: 3.0, count: 1, targetPref: 'building', sprite: 'balloon', rng: 0.5 * TILE, sight: 7.7*TILE, flying: true, targetsAir: false },
    prince: { name: "Prince", cost: 5, rarity: 'epic', type: 'troop', hp: 2000, dmg: 392, spd: 55, hit: 1.4, count: 1, targetPref: 'any', sprite: 'prince', rng: 1.6 * TILE, sight: 5.5*TILE, targetsAir: false, charge: true },
    darkprince: { name: "Dark Prince", cost: 4, rarity: 'epic', type: 'troop', hp: 1300, dmg: 240, spd: 55, hit: 1.3, count: 1, targetPref: 'any', sprite: 'darkprince', rng: 1.2 * TILE, sight: 5.5*TILE, targetsAir: false, splash: true, splashRadius: 1.5 * TILE, charge: true },
    bomber: { name: "Bomber", cost: 2, rarity: 'common', type: 'troop', hp: 398, dmg: 222, spd: 55, hit: 1.8, count: 1, targetPref: 'any', sprite: 'bomber', rng: 4.5 * TILE, sight: 5.5*TILE, targetsAir: false, splash: true, splashRadius: 2.0*TILE },
    icewizard: { name: "Ice Wizard", cost: 3, rarity: 'legendary', type: 'troop', hp: 688, dmg: 90, spd: 50, hit: 1.7, count: 1, targetPref: 'any', sprite: 'icewizard', rng: 5.5 * TILE, sight: 5.5*TILE, targetsAir: true, splash: true, splashRadius: 1.5 * TILE, slows: true },
    firecracker: { name: "Firecracker", cost: 3, rarity: 'common', type: 'troop', hp: 304, dmg: 150, spd: 60, hit: 3.0, count: 1, targetPref: 'any', sprite: 'firecracker', rng: 6.0 * TILE, sight: 8.5*TILE, targetsAir: true, shrapnel: true },
    barbarians: { name: "Barbarians", cost: 5, rarity: 'common', type: 'troop', hp: 670, dmg: 190, spd: 50, hit: 1.3, count: 5, targetPref: 'any', sprite: 'barbarians', rng: 0.8 * TILE, sight: 5.5*TILE, targetsAir: false },
    minions: { name: "Minions", cost: 3, rarity: 'common', type: 'troop', hp: 230, dmg: 102, spd: 80, hit: 1.0, count: 3, targetPref: 'any', sprite: 'minions', rng: 2.0 * TILE, sight: 5.5*TILE, flying: true, targetsAir: true },
    witch: { name: "Witch", cost: 5, rarity: 'epic', type: 'troop', hp: 838, dmg: 134, spd: 50, hit: 0.7, count: 1, targetPref: 'any', sprite: 'witch', rng: 5.0 * TILE, sight: 5.5*TILE, targetsAir: true, spawner: true, splash: true, splashRadius: 1.5*TILE },
    megaknight: { name: "Mega Knight", cost: 7, rarity: 'legendary', type: 'troop', hp: 3993, dmg: 268, spd: 50, hit: 1.7, count: 1, targetPref: 'any', sprite: 'megaknight', rng: 1.2 * TILE, sight: 5.5*TILE, targetsAir: false, splash: true, splashRadius: 2.5*TILE, jump: true },
    golem: { name: "Golem", cost: 8, rarity: 'epic', type: 'troop', hp: 5120, dmg: 312, spd: 30, hit: 2.5, count: 1, targetPref: 'building', sprite: 'golem', rng: 1.0 * TILE, sight: 7.0*TILE, targetsAir: false, deathSpawn: true },
    threem: { name: "3 Musketeers", cost: 9, rarity: 'rare', type: 'troop', hp: 720, dmg: 218, spd: 55, hit: 1.0, count: 3, targetPref: 'any', sprite: 'threem', rng: 6.0 * TILE, sight: 6.0*TILE, targetsAir: true },
    leon: { name: "Leon", cost: 5, rarity: 'legendary', type: 'troop', hp: 1200, dmg: 150, spd: 60, hit: 1.2, count: 1, targetPref: 'any', sprite: 'leon', rng: 1.2 * TILE, sight: 5.5*TILE, targetsAir: false },
    // GOBLIN CARDS
    speargoblins: { name: "Spear Goblins", cost: 2, rarity: 'common', type: 'troop', hp: 133, dmg: 81, spd: 100, hit: 1.7, count: 3, targetPref: 'any', sprite: 'speargoblins', rng: 5.0 * TILE, sight: 5.5*TILE, targetsAir: true },
    dartgoblin: { name: "Dart Goblin", cost: 3, rarity: 'rare', type: 'troop', hp: 260, dmg: 156, spd: 100, hit: 0.7, count: 1, targetPref: 'any', sprite: 'dartgoblin', rng: 6.5 * TILE, sight: 6.5*TILE, targetsAir: true },
    goblingang: { name: "Goblin Gang", cost: 3, rarity: 'common', type: 'troop', hp: 202, dmg: 120, spd: 100, hit: 1.1, count: 6, targetPref: 'any', sprite: 'goblins', rng: 0.8 * TILE, sight: 5.5*TILE, targetsAir: false, mixed: true },
    goblingiant: { name: "Goblin Giant", cost: 6, rarity: 'epic', type: 'troop', hp: 3223, dmg: 176, spd: 45, hit: 1.5, count: 1, targetPref: 'building', sprite: 'goblingiant', rng: 1.2 * TILE, sight: 7.0*TILE, targetsAir: false, deathSpawn: true },
    goblinbarrel: { name: "Goblin Barrel", cost: 3, rarity: 'epic', type: 'spell', hp: 1, dmg: 0, spd: 0, hit: 0, count: 1, targetPref: 'any', sprite: 'goblinbarrel', rng: 0, globalDeploy: true },
    // SPELLS
    fireball: { name: "Fireball", cost: 4, rarity: 'rare', type: 'spell', dmg: 700, radius: 2.5 * TILE, sprite: 'fireball', globalDeploy: true },
    zap: { name: "Zap", cost: 2, rarity: 'common', type: 'spell', dmg: 200, radius: 2.0 * TILE, stunDuration: 0.5, sprite: 'zap', globalDeploy: true },
    rocket: { name: "Rocket", cost: 6, rarity: 'epic', type: 'spell', dmg: 1300, radius: 2.0 * TILE, sprite: 'rocket', globalDeploy: true },
    // BUILDINGS
    goblinhut: { name: "Goblin Hut", cost: 5, rarity: 'rare', type: 'building', hp: 1398, dmg: 0, spd: 0, hit: 0, count: 1, targetPref: 'none', sprite: 'goblinhut', rng: 0, sight: 0, targetsAir: false, isBuilding: true, isSpawner: true, spawnRate: 7.0, spawnCard: 'speargoblins', spawnCount: 1, lifetime: 60 },
    bombtower: { name: "Bomb Tower", cost: 4, rarity: 'rare', type: 'building', hp: 1672, dmg: 160, spd: 0, hit: 1.5, count: 1, targetPref: 'ground', sprite: 'bombtower', rng: 6.0 * TILE, sight: 6.0*TILE, targetsAir: false, isBuilding: true, isDefensive: true, splash: true, splashRadius: 2.0*TILE, deathDamage: 200, lifetime: 40 },
};

// --- STATE ---
// REPLACED KNIGHT WITH LEON FOR FIRST TIME USERS
let defaultDeck = ['leon', 'archer', 'giant', 'fireball', 'minipekka', 'bombtower', 'goblins', 'zap'];
let userDeck = defaultDeck;

let trophies = 0;
let allKeys = Object.keys(CARDS);
let collection = allKeys.filter(k => !userDeck.includes(k)); 

// AUTO-FIX SAVE DATA
if (localStorage.getItem('clashData')) {
    try {
        let data = JSON.parse(localStorage.getItem('clashData'));
        if (data.deck && Array.isArray(data.deck)) {
            let validDeck = data.deck.filter(k => CARDS[k]);
            while(validDeck.length < 8) {
                let missingKey = allKeys.find(k => !validDeck.includes(k) && !collection.includes(k));
                if(missingKey) validDeck.push(missingKey);
                else validDeck.push('knight'); 
            }
            userDeck = validDeck.slice(0, 8); 
            collection = allKeys.filter(k => !userDeck.includes(k));
        }
        trophies = data.trophies || 0;
    } catch(e) { 
        console.log("Corrupt save, resetting.");
        localStorage.removeItem('clashData');
    }
}

let selectedDeckSlot = -1; let selectedCollectionSlot = -1;
let G = null;
let currentDifficulty = 'medium';

const DIFFICULTY_SETTINGS = {
    easy: { elixirMult: 0.7, react: 4.0 },
    medium: { elixirMult: 1.0, react: 2.5 },
    hard: { elixirMult: 2.0, react: 0.8 } 
};

function saveData() {
    localStorage.setItem('clashData', JSON.stringify({ deck: userDeck, trophies: trophies }));
}

// ROBUST RESIZE FUNCTION
function resizeGame() {
    const wrapper = document.getElementById('game-wrapper');
    const winW = window.innerWidth;
    const winH = window.innerHeight;
    
    // We want to fit 540x960 into the window
    // Calculate the scale needed for width and height
    const scaleW = winW / GAME_W;
    const scaleH = winH / GAME_H;
    
    // Use the smaller scale to ensure it fits entirely (contain)
    const scale = Math.min(scaleW, scaleH);
    
    // Set the wrapper size
    const finalW = Math.floor(GAME_W * scale);
    const finalH = Math.floor(GAME_H * scale);
    
    wrapper.style.width = finalW + 'px';
    wrapper.style.height = finalH + 'px';
}

window.addEventListener('resize', resizeGame);
window.onload = () => { resizeGame(); sortAndRender(); updateAvgElixir(); updateMenuUI(); };

function setDifficulty(level) {
    currentDifficulty = level;
    document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('btn-' + level).classList.add('active');
}

function updateAvgElixir() {
    let total = 0; userDeck.forEach(k => total += CARDS[k].cost);
    document.getElementById('avg-elixir').innerText = "Avg: " + (total/8).toFixed(1);
}

function updateMenuUI() {
    document.getElementById('trophy-count').innerText = trophies;
}

function switchTab(name, el) {
    document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.getElementById(name + '-view').classList.add('active');
    el.classList.add('active');
    if(name === 'deck') sortAndRender();
}

function sortAndRender() {
    let criteria = document.getElementById('sort-select').value;
    collection.sort((a,b) => {
        let cA = CARDS[a], cB = CARDS[b];
        if (criteria === 'elixir') return cA.cost - cB.cost;
        if (criteria === 'name') return cA.name.localeCompare(cB.name);
        if (criteria === 'rarity') {
            const rMap = { common: 1, rare: 2, epic: 3, legendary: 4 };
            return rMap[cA.rarity] - rMap[cB.rarity];
        }
        return 0;
    });
    renderDeckMenu();
}

function renderDeckMenu() {
    const deckGrid = document.getElementById('deck-grid');
    const colGrid = document.getElementById('collection-grid');
    deckGrid.innerHTML = ''; colGrid.innerHTML = '';
    userDeck.forEach((key, i) => {
        if(CARDS[key]) {
            let div = createMenuCard(key);
            if(selectedDeckSlot === i) div.classList.add('selected');
            div.onclick = () => handleDeckClick(i, 'deck');
            deckGrid.appendChild(div);
        }
    });
    collection.forEach((key, i) => {
        if(CARDS[key]) {
            let div = createMenuCard(key);
            if(selectedCollectionSlot === i) div.classList.add('selected');
            div.onclick = () => handleDeckClick(i, 'collection');
            colGrid.appendChild(div);
        }
    });
}

function createMenuCard(key) {
    let s = CARDS[key];
    let div = document.createElement('div');
    div.className = `real-card ${s.rarity}`;
    div.innerHTML = `<div class="elixir-drop"><span>${s.cost}</span></div><img src="${SPRITES[s.sprite].src}"><div class="card-name-tag">${s.name}</div>`;
    return div;
}

function handleDeckClick(idx, type) {
    if (type === 'deck') {
        if (selectedCollectionSlot !== -1) {
            let temp = userDeck[idx]; userDeck[idx] = collection[selectedCollectionSlot]; collection[selectedCollectionSlot] = temp;
            selectedCollectionSlot = -1; selectedDeckSlot = -1; saveData(); updateAvgElixir(); sortAndRender();
        } else if (selectedDeckSlot === idx) selectedDeckSlot = -1; else selectedDeckSlot = idx;
    } else {
        if (selectedDeckSlot !== -1) {
            let temp = collection[idx]; collection[idx] = userDeck[selectedDeckSlot]; userDeck[selectedDeckSlot] = temp;
            selectedDeckSlot = -1; selectedCollectionSlot = -1; saveData(); updateAvgElixir(); sortAndRender();
        } else if (selectedCollectionSlot === idx) selectedCollectionSlot = -1; else selectedCollectionSlot = idx;
    }
    renderDeckMenu();
}

function startGame() {
    document.getElementById('menu-layer').style.display = 'none';
    document.getElementById('game-ui-layer').style.display = 'flex'; 
    document.getElementById('end-screen').style.display = 'none';
    resizeGame();
    G = new Game(userDeck, currentDifficulty);
}

function returnToMenu() {
    G = null;
    updateMenuUI();
    document.getElementById('end-screen').style.display = 'none';
    document.getElementById('game-ui-layer').style.display = 'none';
    document.getElementById('menu-layer').style.display = 'flex';
}

class Game {
    constructor(deck, diff) {
        this.t = 0; this.dt = 0.016;
        this.entities = []; this.projectiles = [];
        this.elixir = 5; this.maxElixir = 10;
        this.botElixir = 5; 
        
        this.diffSettings = DIFFICULTY_SETTINGS[diff];
        this.botNextMove = this.diffSettings.react; 
        this.timeLeft = CONSTANTS.GAME_DURATION;
        this.elapsedTime = 0; 
        this.isOvertime = false; this.doubleElixir = false; this.gameOver = false;
        this.isFrozen = false; 
        
        this.hasTriggered2x = false;
        this.hasTriggered3x = false;

        this.myDeck = [...deck];
        this.hand = this.myDeck.slice(0, 4);
        this.queue = this.myDeck.slice(4);
        
        let allTroopsAndSpells = Object.keys(CARDS).filter(k => CARDS[k].type !== 'spell'); 
        let botCardKeys = allTroopsAndSpells.filter(k => !userDeck.includes(k));

        for (let i = botCardKeys.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [botCardKeys[i], botCardKeys[j]] = [botCardKeys[j], botCardKeys[i]];
        }
        
        this.botDeck = botCardKeys.slice(0, 8);
        while (this.botDeck.length < 8) {
            this.botDeck.push(allTroopsAndSpells[Math.floor(Math.random() * allTroopsAndSpells.length)]);
        }
        
        this.botHand = this.botDeck.slice(0, 4);
        this.botQueue = this.botDeck.slice(4);
        
        this.input = { cardIdx: -1, isDragging: false, x: 0, y: 0, valid: false };

        this.spawnTower('blue', CONSTANTS.LANE_LEFT, 610, 2536, false, 'left');
        this.spawnTower('blue', CONSTANTS.LANE_RIGHT, 610, 2536, false, 'right');
        this.spawnTower('blue', CONSTANTS.CENTER_X, 700, 4008, true, 'center'); 
        this.spawnTower('red', CONSTANTS.LANE_LEFT, 170, 2536, false, 'left');
        this.spawnTower('red', CONSTANTS.LANE_RIGHT, 170, 2536, false, 'right');
        this.spawnTower('red', CONSTANTS.CENTER_X, 135, 4008, true, 'center'); 
        
        setTimeout(() => renderHand(), 10);
    }

    spawnTower(team, x, y, hp, isKing, lane) {
        let t = new Entity(team, 'tower', x, y);
        t.maxHp = hp; t.hp = hp; t.dmg = 90; t.range = 7.5 * CONSTANTS.TILE_SIZE; 
        t.spd = 0; t.hitSpeed = 0.8; t.radius = 35; 
        t.isBuilding = true; t.isKing = isKing; t.lane = lane; t.active = !isKing; 
        t.canTargetAir = true; t.sightRange = 7.0*TILE; 
        this.entities.push(t);
    }

    checkDeployValidity(x, y) {
        if(this.input.cardIdx === -1) return false;
        let k = this.hand[this.input.cardIdx];
        let stats = CARDS[k];

        if(stats.globalDeploy) return true;
        if (y > CONSTANTS.DOCK_Y) return false;

        if (stats.type === 'troop') {
            if (y > CONSTANTS.BASE_DEPLOY) return true;
            
            let redLeftAlive = this.entities.some(e => e.team === 'red' && e.lane === 'left' && e.isBuilding && !e.isKing);
            let redRightAlive = this.entities.some(e => e.team === 'red' && e.lane === 'right' && e.isBuilding && !e.isKing);
            
            if (!redLeftAlive && x < CONSTANTS.CENTER_X && y > CONSTANTS.POCKET_Y) return true;
            if (!redRightAlive && x > CONSTANTS.CENTER_X && y > CONSTANTS.POCKET_Y) return true;
            
            return false;
        } 
        
        if (stats.type === 'building') {
            if (y < CONSTANTS.RIVER_Y) return false;
            return true;
        }

        return false;
    }

    handleMove(e) {
        // Must account for the scale of the game wrapper
        const rect = CANVAS.getBoundingClientRect();
        this.input.x = (e.clientX - rect.left) * (CANVAS.width / rect.width);
        this.input.y = (e.clientY - rect.top) * (CANVAS.height / rect.height);
        if(this.input.cardIdx !== -1) this.input.valid = this.checkDeployValidity(this.input.x, this.input.y);
    }

    handleUp(e) {
        if(this.input.isDragging) {
            if(this.input.valid) this.deployCard(this.input.cardIdx, this.input.x, this.input.y);
            this.input.isDragging = false;
            let cardEl = document.getElementById('card-' + this.input.cardIdx);
            if (cardEl) cardEl.classList.remove('dragging');
            renderHand(); 
        }
    }

    handleDown(e) {
        if(this.input.cardIdx !== -1 && !this.input.isDragging) {
            if(this.input.valid) this.deployCard(this.input.cardIdx, this.input.x, this.input.y);
            else { this.input.cardIdx = -1; renderHand(); }
        }
    }

    selectCard(idx) {
        let key = this.hand[idx];
        if(this.elixir >= CARDS[key].cost) {
            if (this.input.cardIdx === idx && !this.input.isDragging) {
                this.input.cardIdx = -1;
            } else {
                this.input.cardIdx = idx;
                this.input.isDragging = true;
                this.input.valid = false;
                document.getElementById('card-'+idx).classList.add('active');
            }
            renderHand();
        }
    }

    deployCard(idx, x, y) {
        let key = this.hand[idx];
        let stats = CARDS[key];
        if(this.elixir >= stats.cost) {
            this.elixir -= stats.cost;
            
            let kTower = this.entities.find(e => e.team === 'blue' && e.isKing);
            let sx = kTower ? kTower.x : 270;
            let sy = kTower ? kTower.y : 800;
            
            // SPELL DEPLOYMENT (Rocket, Goblin Barrel)
            if (stats.type === 'spell' && (key === 'goblinbarrel' || key === 'rocket')) {
                 let p = new Projectile(sx, sy, null, key, 'blue');
                 p.targetPos = {x: x, y: y};
                 p.damage = stats.dmg;
                 p.radius = stats.radius;
                 p.stunDuration = stats.stunDuration || 0;
                 p.speed = (key === 'goblinbarrel') ? 400 : 250;
                 this.projectiles.push(p);
            } 
            // INSTANT SPELL DEPLOYMENT (Fireball, Zap)
            else if (stats.type === 'spell') {
                 let p = new Projectile(x, y, null, key, 'blue'); 
                 p.targetPos = {x: x, y: y};
                 p.damage = stats.dmg;
                 p.radius = stats.radius;
                 p.stunDuration = stats.stunDuration || 0;
                 this.createSpellEffect(p, x, y);
            }
            // BUILDING DEPLOYMENT (Goblin Hut, Bomb Tower)
            else if (stats.type === 'building') {
                let p = new Projectile(sx, sy, null, 'building_deploy', 'blue');
                p.targetPos = {x: x, y: y};
                p.cardKey = key; 
                p.speed = 1000; 
                this.projectiles.push(p);

                this.isFrozen = true;
                setTimeout(() => {
                    this.isFrozen = false;
                }, 100); 

            }
            // TROOP DEPLOYMENT
            else if (key === 'goblingang') {
                 for(let i=0; i<3; i++) {
                      let u = new Entity('blue', 'goblins', x+(i*15-15), y);
                      this.applyStats(u, CARDS['goblins']);
                      this.entities.push(u);
                 }
                 for(let i=0; i<3; i++) {
                      let u = new Entity('blue', 'speargoblins', x+(i*15-15), y+20);
                      this.applyStats(u, CARDS['speargoblins']);
                      this.entities.push(u);
                 }
            } else {
                 // Normal Troop Deployment
                 for(let i=0; i<stats.count; i++) {
                      let ox = (i*20) - (stats.count-1)*10;
                      let u = new Entity('blue', key, x + ox, y);
                      this.applyStats(u, stats);
                      this.entities.push(u);
                 }
            }

            let nextCard = this.queue.shift(); 
            this.queue.push(key); 	         
            this.hand[idx] = nextCard; 	     
            this.input.cardIdx = -1;
            this.input.isDragging = false;
            renderHand(); 
        }
    }
    
    // Handles final building placement after the projectile hits (and the freeze ends)
    placeBuilding(cardKey, x, y, team) {
        let stats = CARDS[cardKey];
        let u = new Entity(team, cardKey, x, y);
        this.applyStats(u, stats);
        u.isBuilding = true;
        this.entities.push(u);
    }

    // Handles the actual damage and spawns the visual effect
    createSpellEffect(spell, x, y) {
        // 1. Apply Damage and Effects
        this.entities.forEach(e => {
            if (e.team === spell.team) return;
            
            let dist = Math.hypot(e.x - x, e.y - y);
            if (dist <= spell.radius + e.radius) {
                e.hp -= spell.damage;
                
                if (spell.stunDuration > 0 && e.stunTimer < spell.stunDuration) {
                    e.stunTimer = spell.stunDuration;
                }
            }
        });
        
        // 2. Spawn Visual Effect or Troops
        if (spell.type === 'goblinbarrel') {
             for(let i=0; i<3; i++) {
                 let ox = Math.cos(i*2.09) * 20;
                 let oy = Math.sin(i*2.09) * 20;
                 let u = new Entity(spell.team, 'goblins', x + ox, y + oy);
                 this.applyStats(u, CARDS['goblins']);
                 this.entities.push(u);
             }
        } else if (spell.type === 'fireball' || spell.type === 'zap' || spell.type === 'rocket' || spell.type === 'bomb') {
             let effect = new SpellEffect(x, y, spell.type, spell.radius);
             this.entities.push(effect);
        }
    }

    applyStats(entity, stats) {
        entity.maxHp = stats.hp; entity.hp = stats.hp; entity.dmg = stats.dmg; entity.range = stats.rng;
        entity.spd = stats.spd; entity.hitSpeed = stats.hit; entity.sprite = stats.sprite; entity.targetPref = stats.targetPref; 
        entity.isFlying = stats.flying || false;
        entity.canTargetAir = stats.targetsAir !== undefined ? stats.targetsAir : true; 
        entity.splash = stats.splash || false;
        entity.splashRadius = stats.splashRadius || 0;
        entity.slows = stats.slows || false;
        entity.shrapnel = stats.shrapnel || false;
        entity.charge = stats.charge || false;
        entity.jump = stats.jump || false;
        
        // Building-specific stats
        entity.isBuilding = stats.isBuilding || false;
        entity.isDefensive = stats.isDefensive || false;
        entity.isSpawner = stats.isSpawner || false;
        entity.spawnCard = stats.spawnCard;
        entity.spawnCount = stats.spawnCount || 1;
        entity.spawnRate = stats.spawnRate || 10;
        entity.deathDamage = stats.deathDamage || 0;
        entity.lifetime = stats.lifetime || 0;

        entity.spawner = stats.spawner || false;
        entity.deathSpawn = stats.deathSpawn || false;
        entity.sightRange = stats.sight || 5.5 * TILE;
    }

    update() {
        if(this.gameOver) return;
        if(this.isFrozen) return; 

        this.t += this.dt;
        this.timeLeft -= this.dt;
        this.elapsedTime += this.dt;

        let t = Math.max(0, Math.ceil(this.timeLeft));
        let m = Math.floor(t / 60);
        let s = t % 60;
        document.getElementById('time-display').innerText = `${m}:${s < 10 ? '0' : ''}${s}`;

        if (this.timeLeft <= 0) {
            if (this.isOvertime) this.checkWinCondition(true); 
            else if (this.checkWinCondition(false) === false) {
                this.isOvertime = true; this.timeLeft = 120; 
                showStatus("Sudden Death!");
            }
        }
        
        let currentMult = 1;
        if (this.elapsedTime >= 240) { 
             currentMult = 3;
             if(!this.hasTriggered3x) { showStatus("3x Elixir!"); this.hasTriggered3x = true; }
        } else if (this.elapsedTime >= 120) { 
             currentMult = 2;
             if(!this.hasTriggered2x) { showStatus("2x Elixir!"); this.hasTriggered2x = true; }
        }

        let regen = (this.dt / 2.8) * currentMult; 
        
        if(this.elixir < 10) this.elixir += regen; 
        if(this.botElixir < 10) this.botElixir += (regen * this.diffSettings.elixirMult);


        ['blue', 'red'].forEach(team => {
            let king = this.entities.find(e => e.team === team && e.isKing);
            if(king && !king.active) {
                if(king.hp < king.maxHp) king.active = true;
                let princessCount = this.entities.filter(e => e.team === team && e.isBuilding && !e.isKing).length;
                if(princessCount < 2) king.active = true;
            }
        });

        if(this.t > this.botNextMove) {
            let available = this.botHand.filter(k => CARDS[k].cost <= this.botElixir);
            
            if(available.length > 0) {
                let k = available[Math.floor(Math.random() * available.length)];
                let stats = CARDS[k];
                this.botElixir -= stats.cost;
                
                let deployX = Math.random() > 0.5 ? CONSTANTS.LANE_LEFT : CONSTANTS.LANE_RIGHT;
                let deployY = 250 + (Math.random() * 50 - 25);
                
                // BOT LOGIC FOR DEPLOYMENT
                if (stats.type === 'spell' && k === 'goblinbarrel') {
                     let p = new Projectile(270, 100, null, 'goblinbarrel', 'red');
                     p.targetPos = {x: deployX, y: 700}; 
                     p.speed = 400; 
                     this.projectiles.push(p);
                } else if (stats.type === 'building') {
                    // Bot building placement 
                    let u = new Entity('red', k, deployX, CONSTANTS.RIVER_Y - 50);
                    this.applyStats(u, stats);
                    u.isBuilding = true;
                    this.entities.push(u);
                } else if (k === 'goblingang') {
                     for(let i=0; i<3; i++) {
                          let u = new Entity('red', 'goblins', deployX+(i*15-15), deployY);
                          this.applyStats(u, CARDS['goblins']);
                          this.entities.push(u);
                     }
                     for(let i=0; i<3; i++) {
                          let u = new Entity('red', 'speargoblins', deployX+(i*15-15), deployY+20);
                          this.applyStats(u, CARDS['speargoblins']);
                          this.entities.push(u);
                     }
                } else {
                    for(let i=0; i<stats.count; i++) {
                        let ox = (i*20) - (stats.count-1)*10;
                        let u = new Entity('red', k, deployX + ox + (Math.random()*10-5), deployY + (Math.random()*10-5));
                        this.applyStats(u, stats); 
                        this.entities.push(u);
                    }
                }

                let handIdx = this.botHand.indexOf(k);
                let nextCard = this.botQueue.shift();
                this.botQueue.push(k);
                this.botHand[handIdx] = nextCard;

                this.botNextMove = this.t + this.diffSettings.react + Math.random();
            } else {
                this.botNextMove = this.t + 0.5;
            }
        }

        this.entities.sort((a,b) => a.y - b.y);
        this.entities.forEach(e => e.update(this));
        
        let dead = this.entities.filter(e => e.hp <= 0 && e.type !== 'effect');
        dead.forEach(e => {
            if(e.isBuilding && e.isKing) this.end(e.team === 'red' ? "BLUE WINS!" : "RED WINS!");

            // Death Damage/Spawn Logic
            if(e.deathDamage > 0) {
                 this.entities.forEach(ent => {
                     if (ent.team !== e.team && Math.hypot(ent.x - e.x, ent.y - e.y) < 3 * TILE) {
                         ent.hp -= e.deathDamage;
                     }
                 });
                 // Trigger bomb impact visual effect
                 let effect = new SpellEffect(e.x, e.y, 'bomb', 3 * TILE, 0.2);
                 this.entities.push(effect);
            }
            if(e.deathSpawn) {
                 if (e.sprite === 'golem') {
                     for(let i=0; i<2; i++) {
                          let g = new Entity(e.team, 'golemite', e.x + (i*20-10), e.y);
                          g.maxHp = 1000; g.hp = 1000; g.dmg = 70; g.spd = 30; g.radius = 15; g.hitSpeed = 1.5;
                          g.sprite = 'golem'; 
                          this.entities.push(g);
                     }
                 } else if (e.sprite === 'goblingiant') {
                     for(let i=0; i<2; i++) {
                          let g = new Entity(e.team, 'speargoblins', e.x + (i*20-10), e.y);
                          this.applyStats(g, CARDS['speargoblins']);
                          this.entities.push(g);
                     }
                 }
            }
        });

        this.entities = this.entities.filter(e => e.hp > 0 || e.type === 'effect');
        this.entities = this.entities.filter(e => e.type !== 'effect' || e.duration > 0);

        this.projectiles.forEach(p => p.update(this));
        this.projectiles = this.projectiles.filter(p => p.active);
    }

    checkWinCondition(forceEnd) {
        let blueTowers = this.entities.filter(e => e.team === 'blue' && e.isBuilding).length;
        let redTowers = this.entities.filter(e => e.team === 'red' && e.isBuilding).length;
        if (blueTowers > redTowers) { this.end("BLUE WINS!"); return true; }
        else if (redTowers > blueTowers) { this.end("RED WINS!"); return true; }
        else { if (forceEnd) this.end("DRAW!"); return false; }
    }

    end(res) {
        if(this.gameOver) return;
        this.gameOver = true;
        let msg = res;
        let change = 0;
        if (res === "BLUE WINS!") { trophies += 30; change = 30; }
        else if (res === "RED WINS!") { trophies = Math.max(0, trophies-30); change = -30; }
        saveData();
        document.getElementById('end-screen').style.display = 'flex';
        document.getElementById('end-msg').innerText = msg;
        document.getElementById('trophy-change').innerText = (change > 0 ? "+" : "") + change + " ??";
    }

    draw() {
        CTX.fillStyle = '#4c9b56'; CTX.fillRect(0,0,CANVAS.width,CANVAS.height);
        CTX.fillStyle = '#56a760';
        for(let r=0; r<32; r++) for(let c=0; c<18; c++) if((r+c)%2===0) CTX.fillRect(c*30, r*30, 30, 30);

        CTX.strokeStyle = 'rgba(255, 255, 255, 0.3)'; CTX.lineWidth = 2; CTX.setLineDash([10, 10]); CTX.beginPath();
        let redLeftAlive = this.entities.some(e => e.team === 'red' && e.lane === 'left' && e.isBuilding && !e.isKing);
        let redRightAlive = this.entities.some(e => e.team === 'red' && e.lane === 'right' && e.isBuilding && !e.isKing);
        let leftY = redLeftAlive ? CONSTANTS.BASE_DEPLOY : CONSTANTS.POCKET_Y;
        CTX.moveTo(0, leftY); CTX.lineTo(CONSTANTS.CENTER_X, leftY); CTX.lineTo(CONSTANTS.CENTER_X, CONSTANTS.BASE_DEPLOY);
        let rightY = redRightAlive ? CONSTANTS.BASE_DEPLOY : CONSTANTS.POCKET_Y;
        CTX.moveTo(CONSTANTS.CENTER_X, rightY); CTX.lineTo(540, rightY);
        if (!redRightAlive) { CTX.moveTo(CONSTANTS.CENTER_X, rightY); CTX.lineTo(CONSTANTS.CENTER_X, CONSTANTS.BASE_DEPLOY); }
        CTX.stroke(); CTX.setLineDash([]);

        CTX.fillStyle = '#4da6ff'; CTX.fillRect(0, CONSTANTS.RIVER_Y - 20, 540, 40);
        CTX.fillStyle = '#8b5a2b';
        CTX.fillRect(CONSTANTS.LANE_LEFT - 30, CONSTANTS.BRIDGE_Y - 30, 60, 60);
        CTX.fillRect(CONSTANTS.LANE_RIGHT - 30, CONSTANTS.BRIDGE_Y - 30, 60, 60);

        this.entities.filter(e => e.type !== 'effect').forEach(e => e.draw(CTX));
        
        this.projectiles.forEach(p => p.draw(CTX));
        
        this.entities.filter(e => e.type === 'effect').forEach(e => e.draw(CTX));


        // Deployment Preview
        if(this.input.cardIdx !== -1) {
            let k = this.hand[this.input.cardIdx];
            let s = CARDS[k];
            let validColor = this.input.valid ? '#fff' : '#f00';
            
            // Draw range circle for troops/defensive building
            if (s.type === 'troop' || (s.isBuilding && s.isDefensive)) {
                CTX.beginPath(); CTX.arc(this.input.x, this.input.y, s.rng, 0, 6.28);
                CTX.fillStyle = this.input.valid ? 'rgba(255, 255, 255, 0.2)' : 'rgba(255, 0, 0, 0.2)';
                CTX.fill(); CTX.strokeStyle = validColor; CTX.lineWidth = 2; CTX.stroke();
            }

            // Draw deploy box or spell radius
            if (s.type === 'spell' || s.type === 'building') {
                CTX.beginPath(); 
                let radius = s.type === 'spell' ? s.radius : 40; 
                if (radius > 0) {
                    CTX.arc(this.input.x, this.input.y, radius, 0, 6.28);
                } else {
                    CTX.rect(this.input.x - 30, this.input.y - 30, 60, 60);
                }
                CTX.fillStyle = this.input.valid ? 'rgba(255, 255, 255, 0.2)' : 'rgba(255, 0, 0, 0.2)';
                CTX.fill(); CTX.strokeStyle = validColor; CTX.lineWidth = 2; CTX.stroke();
            }

            CTX.save(); CTX.globalAlpha = 0.7;
            let img = SPRITES[s.sprite]; 
            if (img) {
                let w = 50, h = 50; 
                CTX.drawImage(img, this.input.x - w/2, this.input.y - h/2, w, h);
            }
            CTX.restore();
        }
    }
}

// SpellEffect for visual-only animations
class SpellEffect {
    constructor(x, y, spellType, radius, duration = 0.2) { 
        this.x = x;
        this.y = y;
        this.type = 'effect';
        this.spellType = spellType;
        this.radius = radius;
        this.duration = duration; 
        this.initialDuration = duration;
        this.hp = 1; 
    }

    update(game) {
        this.duration -= game.dt;
        this.hp = this.duration > 0 ? 1 : 0;
    }

    draw(ctx) {
        if (this.duration <= 0) return;
        
        let progress = 1 - (this.duration / this.initialDuration);
        
        ctx.save();
        ctx.globalAlpha = 1.0 - progress; 

        if (this.spellType === 'fireball' || this.spellType === 'rocket' || this.spellType === 'bomb') {
            let color1 = (this.spellType === 'bomb') ? 'rgba(100, 100, 100' : 'rgba(255, 100, 0';
            let color2 = (this.spellType === 'bomb') ? 'rgba(255, 255, 255' : 'rgba(255, 255, 0';

            ctx.fillStyle = `${color1}, ${ctx.globalAlpha})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius * (1.0 + progress * 0.5), 0, 2 * Math.PI); 
            ctx.fill();
            
            ctx.fillStyle = `${color2}, ${ctx.globalAlpha})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius * 0.6 * (1.0 + progress * 0.2), 0, 2 * Math.PI);
            ctx.fill();

        } else if (this.spellType === 'zap') {
            ctx.fillStyle = `rgba(0, 50, 255, ${ctx.globalAlpha})`;
            ctx.strokeStyle = `rgba(255, 255, 255, ${ctx.globalAlpha})`;
            ctx.lineWidth = 4;
            
            for(let i=0; i<8; i++) {
                 let angle = i * Math.PI / 4;
                 let startX = this.x + Math.cos(angle) * this.radius * 0.5;
                 let startY = this.y + Math.sin(angle) * this.radius * 0.5;
                 let endX = this.x + Math.cos(angle) * this.radius * (1.0 - progress * 0.2);
                 let endY = this.y + Math.sin(angle) * this.radius * (1.0 - progress * 0.2);
                 
                 ctx.beginPath();
                 ctx.moveTo(startX, startY);
                 ctx.lineTo(endX, endY);
                 ctx.stroke();
            }
        }
        
        ctx.restore();
    }
}


class Entity {
    constructor(team, type, x, y) {
        this.team = team; this.type = type; this.x = x; this.y = y;
        this.radius = 20; this.state = 'idle'; this.target = null; this.lastAttack = 0;
        this.sprite = 'knight'; this.animOffset = 0; this.targetPref = 'any';
        this.retargetTimer = 0; this.isBuilding = false; this.isKing = false; 
        this.active = true; this.isFlying = false;
        
        // Mechanics
        this.canTargetAir = true; this.sightRange = 5.5 * TILE;
        this.splash = false; this.splashRadius = 0;
        this.slows = false; this.slowTimer = 0;
        this.stunTimer = 0; 
        this.shrapnel = false;
        this.charge = false; this.chargeTimer = 0; this.isCharging = false;
        this.jump = false; this.jumpTimer = 0; this.isJumping = false; this.jumpTarget = null;
        this.spawner = false; this.spawnTimer = 0;
        this.deathSpawn = false;
        
        // Building lifetime
        this.lifetime = 0; 
        this.deathDamage = 0;
        this.spawnRate = 0;
        this.spawnCard = null;
        this.spawnCount = 0;

        // LEON ABILITY
        this.throwCooldown = 0;
        this.isThrown = false; 
        this.throwStartX = 0; this.throwStartY = 0;
        this.throwDestX = 0; this.throwDestY = 0;
        this.throwProgress = 0;
    }

    update(game) {
        if (this.type === 'effect') {
            this.duration -= game.dt;
            this.hp = this.duration > 0 ? 1 : 0;
            return;
        }

        this.slowTimer -= game.dt;
        this.retargetTimer -= game.dt;
        this.throwCooldown -= game.dt;
        this.stunTimer -= game.dt; 

        // BUILDING LIFETIME
        if (this.isBuilding && !this.isKing && this.lifetime > 0) {
            this.lifetime -= game.dt;
            if (this.lifetime <= 0) this.hp = 0;
        }

        // SPAWNER LOGIC (Goblin Hut)
        if(this.isSpawner && this.spawnCard) {
             this.spawnTimer += game.dt;
             if(this.spawnTimer > this.spawnRate) {
                 this.spawnTimer = 0;
                 let spawnStats = CARDS[this.spawnCard];
                 for(let i=0; i<this.spawnCount; i++) {
                     let u = new Entity(this.team, this.spawnCard, this.x + (Math.random()*40-20), this.y + (Math.random()*40-20));
                     game.applyStats(u, spawnStats);
                     game.entities.push(u);
                 }
             }
        }

        // If stunned or thrown, skip all action and movement logic
        if (this.stunTimer > 0) {
            this.target = null;
            this.animOffset = 0;
            return; 
        }
        if (this.isThrown) {
            this.throwProgress += game.dt * 1.0; 
            if (this.throwProgress >= 1) {
                this.isThrown = false;
                this.x = this.throwDestX;
                this.y = this.throwDestY;
            } else {
                this.x = this.throwStartX + (this.throwDestX - this.throwStartX) * this.throwProgress;
                this.y = this.throwStartY + (this.throwDestY - this.throwStartY) * this.throwProgress;
            }
            return; 
        }
        
        // LEON THROW LOGIC - ON ATTACK
        if (this.sprite === 'leon' && this.throwCooldown <= 0 && this.target && !this.target.isBuilding && !this.target.isFlying) {
             let dist = Math.hypot(this.target.x - this.x, this.target.y - this.y);
             if (dist <= (this.range + this.target.radius)) {
                 this.target.isThrown = true;
                 this.target.throwStartY = this.target.y;
                 this.target.throwStartX = this.target.x;
                 let otherLane = this.target.x < CONSTANTS.CENTER_X ? CONSTANTS.LANE_RIGHT : CONSTANTS.LANE_LEFT;
                 this.target.throwDestX = otherLane;
                 this.target.throwDestY = this.target.y; 
                 this.target.throwProgress = 0;
                 this.throwCooldown = 4.0;
                 this.lastAttack = game.t;
                 return; 
             }
        }

        if(this.isKing && !this.active) { this.target = null; return; }

        let currentSpd = this.slowTimer > 0 ? this.spd * 0.5 : this.spd;
        if (this.isCharging) currentSpd *= 2.0;

        // JUMP LOGIC
        if (this.jump && !this.isJumping) {
            let targets = game.entities.filter(e => e.team !== this.team && !e.isFlying); 
            for(let t of targets) {
                let d = Math.hypot(t.x - this.x, t.y - this.y);
                if (d > 3.5 * CONSTANTS.TILE_SIZE && d < 5 * CONSTANTS.TILE_SIZE) {
                    this.isJumping = true; this.jumpTarget = t; this.jumpTimer = 0;
                    break; 
                }
            }
        }

        if (this.isJumping) {
            this.jumpTimer += game.dt;
            if (this.jumpTarget && this.jumpTarget.hp > 0) {
                let dx = this.jumpTarget.x - this.x; let dy = this.jumpTarget.y - this.y;
                let dist = Math.hypot(dx, dy);
                if (dist < 10 || this.jumpTimer > 1.0) { 
                    this.isJumping = false; 
                    game.entities.forEach(ent => {
                        if (ent.team !== this.team && Math.hypot(ent.x - this.x, ent.y - this.y) < this.splashRadius + ent.radius) {
                             ent.hp -= (this.dmg * 2); 
                        }
                    });
                } else {
                    this.x += (dx/dist) * 300 * game.dt; 
                    this.y += (dy/dist) * 300 * game.dt;
                }
            } else { this.isJumping = false; }
            return; 
        }

        if (!this.target || this.target.hp <= 0 || (this.retargetTimer < 0)) {
            this.target = this.findBestTarget(game.entities);
            this.retargetTimer = 0.5;
        } else {
            let d = Math.hypot(this.target.x - this.x, this.target.y - this.y);
            if (d > this.sightRange) this.target = null;
        }

        if(this.target) {
            let interactDist = this.range + this.target.radius;
            let dist = Math.hypot(this.target.x - this.x, this.target.y - this.y);

            if(dist <= interactDist) {
                if (this.charge) { this.isCharging = false; this.chargeTimer = 0; } 

                if(game.t - this.lastAttack > this.hitSpeed) {
                    this.lastAttack = game.t;
                    if(this.range > 50) {
                        let pType = 'arrow';
                        if(this.sprite === 'bomber') pType = 'bomb';
                        if(this.sprite === 'icewizard') pType = 'ice';
                        if(this.sprite === 'wizard') pType = 'magic';
                        if(this.sprite === 'firecracker') pType = 'rocket';
                        if (this.isBuilding && this.sprite === 'bombtower') pType = 'bomb';

                        // Set damage for the projectile before firing
                        let dmg = this.dmg;
                        
                        let p = new Projectile(this.x, this.y, this.target, pType, this.team, this.splash, this.splashRadius, this.slows, this.shrapnel);
                        p.damage = dmg; 

                        game.projectiles.push(p);
                    } else {
                        let dmg = this.dmg;
                        if (this.charge && this.chargeTimer > 2.0) dmg *= 2; 

                        if (this.splash) {
                             game.entities.forEach(ent => {
                                 if (ent.team !== this.team && Math.hypot(ent.x - this.x, ent.y - this.y) < this.splashRadius + ent.radius) {
                                     ent.hp -= dmg;
                                 }
                             });
                        } else {
                             this.target.hp -= dmg;
                        }
                    }
                }
            } else {
                if (this.charge) {
                    this.chargeTimer += game.dt;
                    if (this.chargeTimer > 2.0) this.isCharging = true;
                }

                if (!this.isBuilding) {
                     let moveTarget = {x: this.target.x, y: this.target.y};
                     if (!this.isFlying) {
                         let riverY = CONSTANTS.RIVER_Y;
                         let onBottom = this.y > riverY;
                         let targetOnBottom = this.target.y > riverY;
                         if (onBottom !== targetOnBottom) {
                             let distLeft = Math.abs(this.x - CONSTANTS.LANE_LEFT);
                             let distRight = Math.abs(this.x - CONSTANTS.LANE_RIGHT);
                             let bridgeX = distLeft < distRight ? CONSTANTS.LANE_LEFT : CONSTANTS.LANE_RIGHT;
                             
                             if (Math.abs(this.x - bridgeX) > 15) {
                                 moveTarget.x = bridgeX;
                                 moveTarget.y = this.y > riverY ? riverY + 50 : riverY - 50; 
                             } else {
                                 moveTarget.x = bridgeX;
                                 moveTarget.y = CONSTANTS.BRIDGE_Y; 
                             }
                         }
                     }
                     let mdx = moveTarget.x - this.x;
                     let mdy = moveTarget.y - this.y;
                     let angle = Math.atan2(mdy, mdx);
                     this.x += Math.cos(angle) * currentSpd * game.dt;
                     this.y += Math.sin(angle) * currentSpd * game.dt;
                     this.animOffset += 0.2; 
                }
            }
        } else {
            if(!this.isBuilding) {
                 let forwardY = this.team === 'blue' ? 0 : 960;
                 if (Math.abs(this.y - forwardY) > 10) {
                      if (!this.isFlying && (this.y > 350 && this.y < 450)) {
                           let distLeft = Math.abs(this.x - CONSTANTS.LANE_LEFT);
                           let distRight = Math.abs(this.x - CONSTANTS.LANE_RIGHT);
                           let bridgeX = distLeft < distRight ? CONSTANTS.LANE_LEFT : CONSTANTS.LANE_RIGHT;
                           
                           if (Math.abs(this.x - bridgeX) > 15) {
                               let dir = bridgeX > this.x ? 1 : -1;
                               this.x += dir * currentSpd * game.dt;
                           } else {
                               this.y += (this.team==='blue'?-1:1) * currentSpd * game.dt;
                           }
                      } else {
                           this.y += (this.team==='blue'?-1:1) * currentSpd * game.dt;
                      }
                 }
            }
        }
    }

    findBestTarget(entities) {
        let min = Infinity;
        let c = null;
        let isTankBuster = this.targetPref === 'building';
        
        entities.forEach(e => {
            if(e.team === this.team) return;
            if(e.type === 'effect') return;

            if (isTankBuster) {
                 if (!e.isBuilding) {
                     let d = Math.hypot(e.x - this.x, e.y - this.y);
                     if (d > 2 * TILE) return; 
                 }
            } else if (this.targetPref === 'ground' && e.isFlying) {
                return;
            }

            if (e.isFlying && !this.canTargetAir) return;
            
            let d = Math.hypot(e.x - this.x, e.y - this.y);
            if (d > this.sightRange) return;

            if(d < min) { min = d; c = e; }
        });
        return c;
    }

    draw(ctx) {
        if (isNaN(this.x) || isNaN(this.y)) return; 

        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(this.x, this.y + 5, this.radius, this.radius/2, 0, 0, 6.28); ctx.fill();

        let img = SPRITES[this.sprite];
        if (!img) return; 

        let w = this.radius * 2.5; let h = this.radius * 2.5;
        let bob = this.isBuilding || this.stunTimer > 0 ? 0 : Math.sin(this.animOffset) * 2; 

        if (this.isThrown) bob -= Math.sin(this.throwProgress * Math.PI) * 100; 

        ctx.save();
        if (this.slowTimer > 0) ctx.filter = 'hue-rotate(180deg) brightness(1.2)'; 
        if (this.isCharging) ctx.filter = 'sepia(1) saturate(5)'; 
        if (this.stunTimer > 0) ctx.globalAlpha = 0.5; 

        ctx.fillStyle = this.team === 'blue' ? '#36f' : '#f33';
        if(this.isBuilding && !this.isKing) {
            ctx.drawImage(SPRITES['building'], this.x - w/2, this.y - h/1.2, w, h);
        } else if (this.isBuilding && this.isKing) {
             ctx.fillRect(this.x-10, this.y-50, 20, 20); 
             if(this.isKing && !this.active) {
               ctx.fillStyle = '#fff'; ctx.font = 'bold 20px Arial'; ctx.fillText('Zzz', this.x - 15, this.y - 60);
             }
        } else {
             ctx.beginPath(); ctx.arc(this.x, this.y-10+bob, 15, 0, 6.28); ctx.fill();
        }

        if (this.isBuilding && !this.isKing) {
             w = 60; h = 60;
             ctx.drawImage(img, this.x - w/2, this.y - h*1.1, w, h);
        } else {
             ctx.drawImage(img, this.x - w/2, this.y - h/1.2 + bob, w, h);
        }
        
        if(!this.isBuilding && CARDS[this.sprite]) {
            let name = CARDS[this.sprite].name;
            ctx.font = "bold 10px Arial"; ctx.textAlign = "center"; ctx.lineWidth = 2.5;
            ctx.strokeStyle = "black"; ctx.fillStyle = "white";
            ctx.strokeText(name, this.x, this.y - h/1.3 + bob);
            ctx.fillText(name, this.x, this.y - h/1.3 + bob);
        }

        ctx.restore();

        // HP BAR
        if (this.type !== 'effect') {
            let pct = Math.max(0, this.hp / this.maxHp);
            let barY = this.y - (this.isBuilding ? 55 : h) - 15;
            
            ctx.fillStyle = '#333'; ctx.fillRect(this.x - 20, barY, 40, 6);
            ctx.fillStyle = this.team === 'blue' ? '#6f6' : '#f66'; ctx.fillRect(this.x - 20, barY, 40 * pct, 6);

            if (this.isBuilding && !this.isKing && this.lifetime > 0) {
                ctx.fillStyle = '#333'; ctx.fillRect(this.x - 20, barY + 7, 40, 3);
                let lifePct = this.lifetime / CARDS[this.sprite].lifetime;
                ctx.fillStyle = 'lightblue'; ctx.fillRect(this.x - 20, barY + 7, 40 * lifePct, 3);
            }
        }
    }
}

class Projectile {
    constructor(x, y, target, type, team, splash, radius, slows, shrapnel) {
        this.x = x; this.y = y; this.target = target;
        this.active = true; this.speed = 350;
        this.type = type; 
        this.team = team;
        this.splash = splash || false;
        this.radius = radius || 0;
        this.slows = slows || false;
        this.shrapnel = shrapnel || false;
        this.vx = 0; this.vy = 0; 
        this.targetPos = null; 
        this.damage = 70; 
        this.stunDuration = 0; 
        this.cardKey = null; 
    }
    
    update(game) {
        if (this.type === 'shrapnel') {
            this.x += this.vx * game.dt;
            this.y += this.vy * game.dt;
            if (this.active) { 
                game.entities.forEach(ent => {
                    if (ent.team !== this.team && Math.hypot(ent.x - this.x, ent.y - this.y) < 20) {
                        ent.hp -= 50; this.active = false;
                    }
                });
            }
            if (Math.random() < 0.05) this.active = false; 
            return;
        }

        // BUILDING DEPLOYMENT PROJECTILE LOGIC (triggers placement freeze)
        if (this.type === 'building_deploy') {
            let dx = this.targetPos.x - this.x;
            let dy = this.targetPos.y - this.y;
            let dist = Math.hypot(dx, dy);

            if (dist < 10) {
                 this.active = false;
                 game.placeBuilding(this.cardKey, this.targetPos.x, this.targetPos.y, this.team);
                 return;
            }
            
            let speed = this.speed;
            this.x += (dx/dist) * speed * game.dt;
            this.y += (dy/dist) * speed * game.dt;
            return;
        }

        // SPELL PROJECTILE LOGIC (Goblin Barrel & Rocket)
        if (this.targetPos && !this.target) {
             let dx = this.targetPos.x - this.x;
             let dy = this.targetPos.y - this.y;
             let dist = Math.hypot(dx, dy);
             
             if (dist < 10) {
                 this.active = false;
                 game.createSpellEffect(this, this.targetPos.x, this.targetPos.y); 
                 return;
             }
             
             let speed = this.speed;
             this.x += (dx/dist) * speed * game.dt;
             this.y += (dy/dist) * speed * game.dt;
             return;
        }

        // STANDARD TROOP/BUILDING PROJECTILE LOGIC
        if(!this.target || this.target.hp <= 0) { this.active = false; return; }
        let dx = this.target.x - this.x; let dy = this.target.y - this.y;
        
        if(Math.hypot(dx, dy) < 10) { 
            this.active = false;
            
            if (this.splash) {
                 // Damage is based on the projectile's stored damage or the source card's damage if available
                 let baseDmg = this.damage || 70;

                 game.entities.forEach(ent => {
                     if (ent.team !== this.team && Math.hypot(ent.x - this.x, ent.y - this.y) < this.radius + ent.radius) {
                         ent.hp -= baseDmg; 
                     }
                 });
                 // Trigger visual effect for splash
                 if (this.type === 'bomb') {
                    game.createSpellEffect(this, this.target.x, this.target.y); 
                 }

            } else {
                 this.target.hp -= this.damage;
                 if (this.slows) this.target.slowTimer = 2.0;
            }

            if (this.shrapnel) {
                let baseAngle = Math.atan2(dy, dx);
                for(let i=-1; i<=1; i++) {
                    let p = new Projectile(this.x, this.y, null, 'shrapnel', this.team);
                    let angle = baseAngle + i * 0.4 + Math.PI; 
                    p.vx = Math.cos(angle) * 400;
                    p.vy = Math.sin(angle) * 400;
                    game.projectiles.push(p);
                }
            }

        } else {
            let angle = Math.atan2(dy, dx);
            this.x += Math.cos(angle) * this.speed * game.dt;
            this.y += Math.sin(angle) * this.speed * game.dt;
        }
    }

    draw(ctx) { 
        if (this.type === 'arrow') { ctx.drawImage(SPRITES['arrow'], this.x-10, this.y-10, 20, 20); } 
        else if (this.type === 'bomb') { ctx.beginPath(); ctx.arc(this.x, this.y, 6, 0, 6.28); ctx.fillStyle = '#333'; ctx.fill(); } 
        else if (this.type === 'magic') { ctx.beginPath(); ctx.arc(this.x, this.y, 6, 0, 6.28); ctx.fillStyle = '#f0f'; ctx.fill(); } 
        else if (this.type === 'ice') { ctx.beginPath(); ctx.arc(this.x, this.y, 6, 0, 6.28); ctx.fillStyle = '#0ff'; ctx.fill(); } 
        else if (this.type === 'rocket') { ctx.drawImage(SPRITES['rocket'], this.x-10, this.y-10, 20, 40); }
        else if (this.type === 'shrapnel') { ctx.fillStyle = '#fa0'; ctx.fillRect(this.x-2, this.y-2, 4, 4); }
        else if (this.type === 'goblinbarrel') { ctx.drawImage(SPRITES['goblinbarrel'], this.x-10, this.y-10, 20, 30); }
        else if (this.type === 'building_deploy') {
             ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
             ctx.beginPath();
             ctx.arc(this.x, this.y, 5, 0, 2 * Math.PI); 
             ctx.fill();
        }
    }
}

window.addEventListener('pointermove', (e) => { if(G) G.handleMove(e); });
window.addEventListener('pointerup', (e) => { if(G) G.handleUp(e); });
CANVAS.addEventListener('pointerdown', (e) => { if(G) G.handleDown(e); });

function showStatus(text) {
    let el = document.getElementById('game-status');
    el.innerText = text; el.style.display = 'block';
    setTimeout(() => { el.style.display = 'none'; }, 3000);
}

function renderHand() {
    let dock = document.getElementById('card-dock');
    dock.innerHTML = '';
    if(!G) return;
    G.hand.forEach((k, i) => {
        let div = document.createElement('div');
        div.className = 'game-card ' + CARDS[k].rarity + (G.input.cardIdx === i ? ' active' : '');
        div.id = 'card-' + i;
        div.innerHTML = `<div class="cost">${CARDS[k].cost}</div><img src="${SPRITES[CARDS[k].sprite].src}"><div class="game-card-name">${CARDS[k].name}</div>`;
        div.onpointerdown = (e) => { G.selectCard(i); e.preventDefault(); };
        dock.appendChild(div);
    });
}

function updateUI() {
    if(!G) return;
    document.getElementById('elixir-fill').style.width = (G.elixir*10)+'%';
    document.getElementById('elixir-text').innerText = Math.floor(G.elixir);
    let m = Math.floor(Math.max(0, G.timeLeft) / 60);
    let s = Math.floor(Math.max(0, G.timeLeft) % 60);
    document.getElementById('time-display').innerText = `${m}:${s < 10 ? '0' : ''}${s}`;
    if (G.isOvertime) document.getElementById('time-display').style.color = '#f00';
    G.hand.forEach((k, i) => {
        let c = document.getElementById('card-' + i);
        if(c) {
             if(G.elixir < CARDS[k].cost) c.classList.add('disabled');
             else c.classList.remove('disabled');
        }
    });
}

function loop() {
    if(G) { G.update(); G.draw(); updateUI(); }
    requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
