<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Clash Royale</title>
    <style>
        /* --- GLOBAL RESET --- */
        * { box-sizing: border-box; }
        body {
            margin: 0; padding: 0;
            background-color: #1a1a1a;
            background-image: radial-gradient(#2a2a2a 1px, transparent 1px);
            background-size: 20px 20px;
            display: flex; justify-content: center; align-items: center;
            height: 100vh; width: 100vw;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden; touch-action: none; user-select: none;
        }

        #game-wrapper {
            position: relative;
            background: #000;
            border: 12px solid #0a0a0a; 
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            overflow: hidden;
            width: 360px; height: 640px; 
        }

        canvas { display: block; width: 100%; height: 100%; background: #4c9b56; }

        /* --- LAYERS --- */
        .full-layer {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column;
        }

        /* --- MENU STYLES --- */
        #menu-layer {
            background: linear-gradient(135deg, #3b607d, #2a4055);
            pointer-events: auto; z-index: 200; 
        }

        .top-bar {
            width: 100%; height: 60px; background: rgba(0,0,0,0.3);
            display: flex; justify-content: space-between; padding: 10px 20px;
            color: white; font-weight: bold; font-size: 14px; flex-shrink: 0;
        }
        .resource { display: flex; align-items: center; gap: 5px; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 15px; }
        .gold-icon { width: 15px; height: 15px; background: gold; border-radius: 50%; border: 1px solid #fff; box-shadow: 0 2px 2px rgba(0,0,0,0.5); }
        .gem-icon { width: 15px; height: 15px; background: #5f5; border-radius: 50%; border: 1px solid #fff; box-shadow: 0 2px 2px rgba(0,0,0,0.5); }

        #view-container { flex-grow: 1; position: relative; width: 100%; overflow: hidden; }
        .view { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; align-items: center; }
        .view.active { display: flex; }

        /* BATTLE TAB */
        .arena-graphic {
            flex-grow: 1; width: 100%; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            background: url('data:image/svg+xml;utf8,<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><rect width="100" height="100" fill="%234c9b56" opacity="0.3"/></svg>');
        }
        #arena-title { font-size: 24px; color: #fff; text-shadow: 0 2px 0 #000; margin-bottom: 20px; font-weight: 900; text-transform: uppercase; }
        
        .battle-btn {
            width: 160px; height: 70px; background: linear-gradient(to bottom, #ffeb3b, #fbc02d);
            border: 3px solid #fff; border-radius: 8px;
            box-shadow: 0 4px 0 #f57f17, 0 10px 10px rgba(0,0,0,0.4);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            cursor: pointer; animation: btnPulse 2s infinite; pointer-events: auto; margin-bottom: 20px;
        }
        .battle-text { font-size: 24px; font-weight: 900; color: #5d4037; text-transform: uppercase; -webkit-text-stroke: 1px #fff; }
        
        /* DIFFICULTY SELECTOR */
        .diff-container { display: flex; gap: 10px; margin-top: 10px; pointer-events: auto; }
        .diff-btn {
            padding: 8px 15px; border: 2px solid #fff; border-radius: 20px;
            background: #444; color: #ccc; font-weight: bold; cursor: pointer;
            text-shadow: 1px 1px 0 #000; font-size: 12px; transition: all 0.2s;
        }
        .diff-btn.active { background: #3c9; color: white; transform: scale(1.1); box-shadow: 0 0 10px #3c9; border-color: #fff; }

        @keyframes btnPulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* DECK TAB */
        #deck-view { background: #2a3a4a; padding: 10px; overflow-y: auto; }
        .deck-header {
            width: 100%; color: #fff; text-shadow: 1px 1px 0 #000;
            margin-bottom: 5px; font-weight: 800; font-size: 14px;
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid #555; padding-bottom: 5px;
        }
        .deck-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; width: 100%; margin-bottom: 20px; padding: 5px; }

        /* SORT DROPDOWN */
        #sort-select {
            background: #444; color: white; border: 1px solid #777;
            border-radius: 4px; padding: 2px 5px; font-size: 11px;
            font-family: inherit; cursor: pointer;
        }

        /* CARDS */
        .real-card {
            width: 100%; aspect-ratio: 3/4; border-radius: 6px;
            position: relative; cursor: pointer;
            display: flex; flex-direction: column; align-items: center; justify-content: flex-end;
            box-shadow: 0 4px 6px rgba(0,0,0,0.6); transition: transform 0.1s; overflow: visible; 
        }
        .real-card.selected { transform: translateY(-5px); box-shadow: 0 0 15px #0f0; z-index: 10; }
        .real-card.active { transform: translateY(-15px); border-color: #ff0; box-shadow: 0 0 15px #ff0; }
        
        .real-card.common { background: radial-gradient(circle at center, #9ebdd6 40%, #5e7fa0 100%); border: 3px solid #5e7fa0; border-bottom: 6px solid #4a6a8a; }
        .real-card.rare { background: radial-gradient(circle at center, #ffdfaa 40%, #d68a29 100%); border: 3px solid #dba02c; border-bottom: 6px solid #b37e1e; }
        .real-card.epic { background: radial-gradient(circle at center, #d980fa 40%, #8708c0 100%); border: 3px solid #b636d6; border-bottom: 6px solid #8616a6; }
        .real-card.legendary { background: radial-gradient(circle at center, #4ff 20%, #d5f 100%); border: 3px solid #4ff; border-bottom: 6px solid #2cc; animation: legendGlow 3s infinite; }
        
        @keyframes legendGlow { 0% { box-shadow: 0 0 5px #4ff; } 50% { box-shadow: 0 0 15px #d5f; } 100% { box-shadow: 0 0 5px #4ff; } }

        .real-card img { 
            position: absolute; top: 5%; left: 5%; width: 90%; height: 75%; 
            object-fit: contain; filter: drop-shadow(0px 5px 3px rgba(0,0,0,0.5)); z-index: 1; pointer-events: none; 
        }

        .elixir-drop {
            position: absolute; top: -5px; left: -5px; width: 22px; height: 22px;
            background: radial-gradient(circle at 35% 35%, #f5abff, #b029ff, #570080);
            border: 1px solid #30004a; box-shadow: 2px 3px 5px rgba(0,0,0,0.6);
            display: flex; justify-content: center; align-items: center;
            font-family: 'Arial Black', sans-serif; font-size: 12px; color: white;
            text-shadow: 1px 1px 0 #000; z-index: 5;
            border-top-left-radius: 50%; border-top-right-radius: 50%;
            border-bottom-left-radius: 50%; border-bottom-right-radius: 5%;
            transform: rotate(45deg);
        }
        .elixir-drop span { transform: rotate(-45deg); margin-top: 2px; margin-left: 2px; }

        .card-name-tag {
            position: relative; width: 105%; text-align: center;
            font-family: 'Arial Black', sans-serif; font-size: 7px; color: #fff;
            text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000;
            margin-bottom: 4px; z-index: 3; letter-spacing: 0.5px;
        }

        /* BOTTOM NAV */
        .bottom-tabs {
            width: 100%; height: 60px; background: #222;
            display: flex; justify-content: space-evenly; align-items: center;
            border-top: 2px solid #444; flex-shrink: 0; pointer-events: auto;
        }
        .tab { width: 60px; height: 40px; background: #444; border-radius: 5px; display: flex; justify-content: center; align-items: center; font-size: 24px; cursor: pointer; color: #888; }
        .tab.active { background: #ffe040; color: #530; border: 2px solid #fff; transform: translateY(-5px); }

        /* GAME UI */
        #game-ui-layer { justify-content: space-between; z-index: 100; display: none; }
        #top-hud { width: 100%; height: 60px; display: flex; justify-content: center; align-items: flex-start; padding-top: 10px; position: relative; pointer-events: none;}
        
        #timer-box { 
            position: absolute; left: 15px; top: 15px;
            background: rgba(0,0,0,0.6); color: white; padding: 5px 15px; 
            border-radius: 20px; font-weight: bold; font-size: 18px; 
            border: 2px solid #444; display: flex; flex-direction: column; align-items: center; 
            font-family: 'Arial Black', sans-serif; pointer-events: auto;
        }

        #game-status { font-size: 10px; color: #ffeb3b; text-transform: uppercase; margin-top: 2px; display: none; }
        
        #home-btn {
            position: absolute; right: 15px; top: 15px; width: 35px; height: 35px;
            background: #d32f2f; border: 2px solid #fff; border-radius: 8px;
            color: white; font-size: 20px; font-weight: bold;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; pointer-events: auto; box-shadow: 0 4px 0 #8b0000; text-shadow: 1px 1px 0 black;
        }
        #home-btn:active { transform: translateY(4px); box-shadow: none; }

        #bottom-dock-container { width: 100%; display: flex; flex-direction: column; align-items: center; padding-bottom: 5px; pointer-events: auto; }
        #elixir-container { width: 92%; height: 22px; background: #111; margin-bottom: 4px; border-radius: 10px; border: 2px solid #000; position: relative; box-shadow: 0 2px 5px rgba(0,0,0,0.5); overflow: hidden; }
        #elixir-fill { height: 100%; width: 50%; background: linear-gradient(180deg, #d56aff, #7600bc); transition: width 0.1s linear; }
        #elixir-text { position: absolute; right: 10px; top: 0; color: #fff; font-weight: 900; line-height: 22px; font-family: 'Arial Black', sans-serif; }
        #card-dock {
            width: 100%; height: 110px;
            background: url('data:image/svg+xml;utf8,<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg"><rect width="100" height="100" fill="%234a3020"/><path d="M0 0 L100 100 M100 0 L0 100" stroke="%233a2010" stroke-width="2"/></svg>');
            background-size: 20px 20px; border-top: 4px solid #2a1a10;
            display: flex; justify-content: space-evenly; align-items: center;
        }

        .game-card {
            width: 19%; aspect-ratio: 3/4; border-radius: 6px; position: relative; cursor: grab; overflow: hidden;
            box-shadow: 0 4px 5px rgba(0,0,0,0.5); transition: transform 0.1s; display: flex; justify-content: center; align-items: center; flex-direction: column;
        }
        .game-card.active { transform: translateY(-15px) scale(1.05); border-color: #ffff00; box-shadow: 0 0 10px #ffff00; }
        .game-card.dragging { opacity: 0; }
        .game-card.disabled { filter: grayscale(100%); cursor: not-allowed; }
        .game-card.common { background: linear-gradient(135deg, #6b9ac4, #3b6a94); border: 2px solid #4a7a9a; }
        .game-card.rare   { background: linear-gradient(135deg, #f09e38, #c06e08); border: 2px solid #d07e18; }
        .game-card.epic   { background: linear-gradient(135deg, #b738f0, #8708c0); border: 2px solid #9718d0; }
        .game-card.legendary { background: linear-gradient(135deg, #4ff, #d5f); border: 2px solid #4ff; }
        .game-card img { width: 85%; height: 70%; object-fit: contain; margin-top: 2px; z-index:1; pointer-events: none; }
        .game-card .cost { position: absolute; top: -5px; left: -5px; width: 22px; height: 22px; background: #d0f; color: white; border-radius: 50%; border: 2px solid white; display: flex; justify-content: center; align-items: center; font-weight: bold; font-size: 12px; z-index: 2; }
        .game-card-name { width: 100%; background: rgba(0,0,0,0.6); color: white; font-size: 8px; font-weight: bold; text-align: center; padding: 2px 0; margin-top: auto; white-space: nowrap; overflow: hidden; z-index: 2; }

        #end-screen { display: none; background: rgba(0,0,0,0.85); z-index: 300; pointer-events: auto; align-items: center; justify-content: center; }
    </style>
</head>
<body>

<div id="game-wrapper">
    <div id="menu-layer" class="full-layer">
        <div class="top-bar">
            <div class="resource"><div class="gold-icon"></div> 1250</div>
            <div class="resource"><div class="gem-icon"></div> 50</div>
        </div>
        
        <div id="view-container">
            <div id="battle-view" class="view active">
                <div class="arena-graphic">
                    <div id="arena-title">Training Camp</div>
                    <div class="battle-btn" onclick="startGame()">
                        <div class="battle-text">Battle</div>
                    </div>
                    <div style="color:#aaa; font-size:12px; font-weight:bold; margin-bottom:5px;">DIFFICULTY</div>
                    <div class="diff-container">
                        <div id="btn-easy" class="diff-btn" onclick="setDifficulty('easy')">Easy</div>
                        <div id="btn-medium" class="diff-btn active" onclick="setDifficulty('medium')">Medium</div>
                        <div id="btn-hard" class="diff-btn" onclick="setDifficulty('hard')">Hard</div>
                    </div>
                </div>
            </div>
            <div id="deck-view" class="view">
                <div class="deck-header">
                    <span>Battle Deck</span>
                    <span id="avg-elixir" style="font-size: 10px; font-weight: normal; color: #ccc;">Avg Elixir: 3.5</span>
                </div>
                <div id="deck-grid" class="deck-grid"></div>
                <div style="height: 2px; background: #555; width: 100%; margin: 10px 0;"></div>
                <div class="deck-header">
                    <span>Card Collection</span>
                    <select id="sort-select" onchange="sortAndRender()">
                        <option value="elixir">By Elixir</option>
                        <option value="rarity">By Rarity</option>
                        <option value="name">By Name</option>
                    </select>
                </div>
                <div id="collection-grid" class="deck-grid"></div>
            </div>
        </div>

        <div class="bottom-tabs">
            <div class="tab" onclick="switchTab('deck', this)">üé¥</div>
            <div class="tab active" onclick="switchTab('battle', this)">‚öîÔ∏è</div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>
    
    <div id="game-ui-layer" class="full-layer">
        <div id="top-hud">
            <div id="timer-box">
                <span id="time-display">3:00</span>
                <span id="game-status"></span>
            </div>
            <div id="home-btn" onclick="returnToMenu()">‚åÇ</div>
        </div>
        
        <div id="bottom-dock-container">
            <div id="elixir-container">
                <div id="elixir-fill"></div>
                <div id="elixir-text">5</div>
            </div>
            <div id="card-dock"></div>
        </div>
    </div>
    
    <div id="end-screen" class="full-layer">
        <h1 id="end-msg" style="font-size: 40px; color: #ffcc00; -webkit-text-stroke: 2px black;">WINNER</h1>
        <button onclick="returnToMenu()" style="padding: 15px 30px; background: #3c9; border:none; border-radius:5px; color:white; font-weight:bold; font-size:18px; cursor:pointer;">OK</button>
    </div>
</div>

<script>
// --- ASSETS ---
const SPRITES = {};
function createAsset(name, svgContent) {
    const header = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">`;
    const blob = new Blob([header + svgContent + `</svg>`], {type: 'image/svg+xml'});
    const img = new Image();
    img.src = URL.createObjectURL(blob);
    SPRITES[name] = img;
}

// GRAPHICS
createAsset('knight', `<rect x="22" y="35" width="56" height="45" rx="8" fill="#9aa" stroke="#222" stroke-width="3"/><circle cx="50" cy="38" r="22" fill="#cfcfcf" stroke="#222" stroke-width="3"/><rect x="45" y="10" width="10" height="20" fill="#c00"/><circle cx="42" cy="36" r="3" fill="#000"/><circle cx="58" cy="36" r="3" fill="#000"/><path d="M40 45 Q50 50 60 45" stroke="#000" stroke-width="2" fill="none"/>`);
createAsset('archer', `<circle cx="50" cy="40" r="22" fill="#fec" stroke="#222" stroke-width="3"/><path d="M18 42 Q50 5 82 42 L70 85 Q50 95 30 85 Z" fill="#f06"/><circle cx="42" cy="38" r="3" fill="#000"/><circle cx="58" cy="38" r="3" fill="#000"/><path d="M10 55 Q50 100 90 55" fill="none" stroke="#630" stroke-width="4"/><line x1="12" y1="55" x2="88" y2="55" stroke="#fff" stroke-width="1"/>`);
createAsset('giant', `<rect x="18" y="40" width="64" height="45" rx="10" fill="#b87" stroke="#222" stroke-width="3"/><circle cx="50" cy="30" r="20" fill="#fca" stroke="#222" stroke-width="3"/><circle cx="44" cy="28" r="3" fill="#000"/><circle cx="56" cy="28" r="3" fill="#000"/><path d="M42 36 Q50 42 58 36" stroke="#000" stroke-width="2" fill="none"/>`);
createAsset('pekka', `<path d="M20 25 L35 10 L50 22 L65 10 L80 25 L75 85 L25 85 Z" fill="#334" stroke="#111" stroke-width="3"/><circle cx="42" cy="45" r="4" fill="#0ff"/><circle cx="58" cy="45" r="4" fill="#0ff"/><path d="M15 30 L30 45 M85 30 L70 45" stroke="#556" stroke-width="4"/>`);
createAsset('minipekka', `<rect x="25" y="30" width="50" height="50" rx="6" fill="#556" stroke="#111" stroke-width="3"/><circle cx="50" cy="45" r="6" fill="#0ff"/><rect x="18" y="45" width="10" height="35" fill="#778"/><rect x="72" y="45" width="10" height="35" fill="#778"/>`);
createAsset('musketeer', `<circle cx="50" cy="42" r="22" fill="#fec" stroke="#222" stroke-width="3"/><path d="M25 42 Q50 10 75 42 Z" fill="#445"/><circle cx="44" cy="40" r="3" fill="#000"/><circle cx="56" cy="40" r="3" fill="#000"/><rect x="60" y="45" width="28" height="8" fill="#532"/>`);
createAsset('wizard', `<circle cx="50" cy="38" r="20" fill="#fec" stroke="#222" stroke-width="3"/><path d="M22 38 L50 5 L78 38 Z" fill="#33f"/><path d="M30 85 L70 85 L50 30 Z" fill="#33f"/><circle cx="60" cy="48" r="8" fill="#fa0"/>`);
createAsset('dragon', `<circle cx="50" cy="35" r="20" fill="#6d6" stroke="#222" stroke-width="3"/><path d="M20 55 Q50 75 80 55 L60 85 L40 85 Z" fill="#6d6"/><circle cx="45" cy="33" r="3" fill="#000"/><circle cx="55" cy="33" r="3" fill="#000"/>`);
createAsset('skeletons', `<circle cx="30" cy="45" r="10" fill="#eee" stroke="#000" stroke-width="2"/><circle cx="70" cy="45" r="10" fill="#eee" stroke="#000" stroke-width="2"/><circle cx="50" cy="72" r="12" fill="#eee" stroke="#000" stroke-width="2"/>`);
createAsset('arrow', `<line x1="10" y1="50" x2="80" y2="50" stroke="#532" stroke-width="4"/><path d="M80 50 L65 40 L65 60 Z" fill="#eee"/>`);
createAsset('valkyrie', `<circle cx="50" cy="38" r="20" fill="#fec"/><path d="M30 85 L70 85 L60 30 L40 30 Z" fill="#c63"/><path d="M20 55 Q50 70 80 55" stroke="#963" stroke-width="6"/>`);
createAsset('hog', `<ellipse cx="50" cy="55" rx="30" ry="20" fill="#d9a"/><circle cx="40" cy="48" r="4" fill="#000"/><circle cx="60" cy="48" r="4" fill="#000"/>`);
createAsset('balloon', `<ellipse cx="50" cy="30" rx="22" ry="26" fill="#333"/><rect x="40" y="55" width="20" height="20" fill="#754"/>`);
createAsset('prince', `<circle cx="50" cy="35" r="18" fill="#fec"/><path d="M35 10 L65 10 L55 35 L45 35 Z" fill="#fc0"/>`);
createAsset('darkprince', `<circle cx="50" cy="35" r="18" fill="#bbb"/><path d="M35 10 L65 10 L55 35 L45 35 Z" fill="#333"/><path d="M25 60 Q50 75 75 60" stroke="#444" stroke-width="6"/>`);
createAsset('bomber', `<circle cx="50" cy="38" r="18" fill="#eee"/><circle cx="50" cy="65" r="10" fill="#333"/>`);
createAsset('icewizard', `<circle cx="50" cy="38" r="20" fill="#def"/><path d="M22 38 L50 5 L78 38 Z" fill="#6cf"/><circle cx="60" cy="48" r="8" fill="#9ff"/>`);
createAsset('firecracker', `<circle cx="50" cy="38" r="18" fill="#fec"/><rect x="60" y="50" width="20" height="6" fill="#900"/><line x1="80" y1="53" x2="95" y2="53" stroke="#fa0" stroke-width="2"/>`);
createAsset('barbarians', `<circle cx="30" cy="45" r="14" fill="#fec"/><circle cx="70" cy="45" r="14" fill="#fec"/><path d="M20 75 L40 75" stroke="#963" stroke-width="6"/><path d="M60 75 L80 75" stroke="#963" stroke-width="6"/>`);
createAsset('minions', `<circle cx="40" cy="40" r="12" fill="#55f"/><circle cx="60" cy="40" r="12" fill="#55f"/><path d="M30 50 L40 70 L50 50 Z" fill="#88f"/><path d="M70 50 L60 70 L50 50 Z" fill="#88f"/>`);
createAsset('goblins', `<circle cx="30" cy="30" r="15" fill="#4d4" stroke="#050"/><circle cx="70" cy="30" r="15" fill="#4d4" stroke="#050"/><circle cx="50" cy="70" r="18" fill="#4d4" stroke="#050"/><path d="M45 75 L55 75" stroke="#000" stroke-width="2"/>`);
createAsset('witch', `<circle cx="50" cy="35" r="20" fill="#d9f"/><path d="M20 85 L50 35 L80 85" fill="#537"/><circle cx="40" cy="35" r="3" fill="#f0f"/><circle cx="60" cy="35" r="3" fill="#f0f"/>`);
createAsset('megaknight', `<rect x="20" y="20" width="60" height="60" rx="10" fill="#333"/><circle cx="50" cy="35" r="15" fill="#222" stroke="#000"/><rect x="15" y="45" width="20" height="40" fill="#222"/><rect x="65" y="45" width="20" height="40" fill="#222"/>`);
createAsset('golem', `<path d="M30 80 L50 20 L70 80" fill="#876"/><circle cx="50" cy="30" r="15" fill="#a98"/><rect x="20" y="40" width="20" height="40" fill="#654"/><rect x="60" y="40" width="20" height="40" fill="#654"/>`);
createAsset('threem', `<circle cx="30" cy="40" r="12" fill="#fec"/><circle cx="50" cy="60" r="12" fill="#fec"/><circle cx="70" cy="40" r="12" fill="#fec"/>`);

const CANVAS = document.getElementById('gameCanvas');
const CTX = CANVAS.getContext('2d');
CANVAS.width = 540; CANVAS.height = 960;
const TILE = 30;

const CONSTANTS = {
    LANE_LEFT: 4 * TILE, LANE_RIGHT: 14 * TILE, RIVER_Y: 400, BRIDGE_Y: 400, BASE_DEPLOY: 440,
    DOCK_Y: 820, POCKET_Y: 180, CENTER_X: 540 / 2, TILE_SIZE: TILE,
    GAME_DURATION: 180, DOUBLE_ELIXIR_TIME: 60, OVERTIME_DURATION: 120 
};

// 24 CARDS
const CARDS = {
    knight: { name: "Knight", cost: 3, rarity: 'common', hp: 1766, dmg: 202, spd: 50, hit: 1.2, count: 1, type: 'melee', targetPref: 'any', sprite: 'knight', rng: 1.2 * TILE, targetsAir: false },
    archer: { name: "Archers", cost: 3, rarity: 'common', hp: 304, dmg: 107, spd: 55, hit: 0.9, count: 2, type: 'range', targetPref: 'any', sprite: 'archer', rng: 5.0 * TILE, targetsAir: true },
    giant:  { name: "Giant", cost: 5, rarity: 'rare', hp: 4091, dmg: 254, spd: 35, hit: 1.5, count: 1, type: 'tank', targetPref: 'building', sprite: 'giant', rng: 1.2 * TILE, targetsAir: false },
    pekka:  { name: "Pekka", cost: 7, rarity: 'epic', hp: 3760, dmg: 816, spd: 35, hit: 1.8, count: 1, type: 'melee', targetPref: 'any', sprite: 'pekka', rng: 1.6 * TILE, targetsAir: false },
    minipekka: { name: "Mini Pekka", cost: 4, rarity: 'rare', hp: 1361, dmg: 720, spd: 80, hit: 1.6, count: 1, type: 'melee', targetPref: 'any', sprite: 'minipekka', rng: 1.2 * TILE, targetsAir: false },
    musketeer: { name: "Musketeer", cost: 4, rarity: 'rare', hp: 720, dmg: 218, spd: 55, hit: 1.0, count: 1, type: 'range', targetPref: 'any', sprite: 'musketeer', rng: 6.0 * TILE, targetsAir: true },
    goblins:   { name: "Goblins", cost: 2, rarity: 'common', hp: 202, dmg: 120, spd: 100, hit: 1.1, count: 3, type: 'melee', targetPref: 'any', sprite: 'goblins', rng: 0.8 * TILE, targetsAir: false },
    dragon:    { name: "Baby Dragon", cost: 4, rarity: 'epic', hp: 1152, dmg: 160, spd: 75, hit: 1.5, count: 1, type: 'range', targetPref: 'any', sprite: 'dragon', rng: 3.5 * TILE, flying: true, targetsAir: true, splash: true, splashRadius: 2.5*TILE },
    wizard:    { name: "Wizard", cost: 5, rarity: 'rare', hp: 720, dmg: 281, spd: 55, hit: 1.4, count: 1, type: 'range', targetPref: 'any', sprite: 'wizard', rng: 5.5 * TILE, targetsAir: true, splash: true, splashRadius: 2.0*TILE },
    skeletons: { name: "Skeletons", cost: 1, rarity: 'common', hp: 81, dmg: 81, spd: 80, hit: 1.0, count: 3, type: 'melee', targetPref: 'any', sprite: 'skeletons', rng: 0.5 * TILE, targetsAir: false },
    valkyrie: { name: "Valkyrie", cost: 4, rarity: 'rare', hp: 1908, dmg: 267, spd: 55, hit: 1.5, count: 1, type: 'melee', targetPref: 'any', sprite: 'valkyrie', rng: 1.5 * TILE, targetsAir: false, splash: true, splashRadius: 2.0*TILE },
    hog: { name: "Hog Rider", cost: 4, rarity: 'rare', hp: 1696, dmg: 318, spd: 100, hit: 1.6, count: 1, type: 'melee', targetPref: 'building', sprite: 'hog', rng: 1.2 * TILE, targetsAir: false },
    balloon: { name: "Balloon", cost: 5, rarity: 'epic', hp: 1680, dmg: 960, spd: 55, hit: 3.0, count: 1, type: 'melee', targetPref: 'building', sprite: 'balloon', rng: 0.5 * TILE, flying: true, targetsAir: false },
    prince: { name: "Prince", cost: 5, rarity: 'epic', hp: 2000, dmg: 392, spd: 55, hit: 1.4, count: 1, type: 'melee', targetPref: 'any', sprite: 'prince', rng: 1.6 * TILE, targetsAir: false, charge: true },
    darkprince: { name: "Dark Prince", cost: 4, rarity: 'epic', hp: 1300, dmg: 240, spd: 55, hit: 1.3, count: 1, type: 'melee', targetPref: 'any', sprite: 'darkprince', rng: 1.2 * TILE, targetsAir: false, splash: true, splashRadius: 1.5 * TILE, charge: true },
    bomber: { name: "Bomber", cost: 2, rarity: 'common', hp: 398, dmg: 222, spd: 55, hit: 1.8, count: 1, type: 'range', targetPref: 'any', sprite: 'bomber', rng: 4.5 * TILE, targetsAir: false, splash: true, splashRadius: 2.0*TILE },
    icewizard: { name: "Ice Wizard", cost: 3, rarity: 'epic', hp: 688, dmg: 90, spd: 50, hit: 1.7, count: 1, type: 'range', targetPref: 'any', sprite: 'icewizard', rng: 5.5 * TILE, targetsAir: true, splash: true, splashRadius: 1.5*TILE, slows: true },
    firecracker: { name: "Firecracker", cost: 3, rarity: 'common', hp: 304, dmg: 150, spd: 60, hit: 3.0, count: 1, type: 'range', targetPref: 'any', sprite: 'firecracker', rng: 6.0 * TILE, targetsAir: true, shrapnel: true },
    barbarians: { name: "Barbarians", cost: 5, rarity: 'common', hp: 670, dmg: 190, spd: 50, hit: 1.3, count: 5, type: 'melee', targetPref: 'any', sprite: 'barbarians', rng: 0.8 * TILE, targetsAir: false },
    minions: { name: "Minions", cost: 3, rarity: 'common', hp: 230, dmg: 102, spd: 80, hit: 1.0, count: 3, type: 'melee', targetPref: 'any', sprite: 'minions', rng: 2.0 * TILE, flying: true, targetsAir: true },
    witch: { name: "Witch", cost: 5, rarity: 'epic', hp: 838, dmg: 134, spd: 50, hit: 0.7, count: 1, type: 'range', targetPref: 'any', sprite: 'witch', rng: 5.0 * TILE, targetsAir: true, spawner: true, splash: true, splashRadius: 1.5*TILE },
    megaknight: { name: "Mega Knight", cost: 7, rarity: 'legendary', hp: 3993, dmg: 268, spd: 50, hit: 1.7, count: 1, type: 'melee', targetPref: 'any', sprite: 'megaknight', rng: 1.2 * TILE, targetsAir: false, splash: true, splashRadius: 2.5*TILE, jump: true },
    golem: { name: "Golem", cost: 8, rarity: 'epic', hp: 5120, dmg: 312, spd: 30, hit: 2.5, count: 1, type: 'tank', targetPref: 'building', sprite: 'golem', rng: 1.0 * TILE, targetsAir: false, deathSpawn: true },
    threem: { name: "3 Musketeers", cost: 9, rarity: 'rare', hp: 720, dmg: 218, spd: 55, hit: 1.0, count: 3, type: 'range', targetPref: 'any', sprite: 'threem', rng: 6.0 * TILE, targetsAir: true }
};

// --- STATE & LOCAL STORAGE ---
let userDeck = ['knight', 'archer', 'giant', 'pekka', 'minipekka', 'musketeer', 'goblins', 'dragon'];
let allKeys = Object.keys(CARDS);
let collection = allKeys.filter(k => !userDeck.includes(k)); 

// LOAD DATA
if (localStorage.getItem('clashDeck')) {
    try {
        let savedDeck = JSON.parse(localStorage.getItem('clashDeck'));
        // Validate deck
        if (Array.isArray(savedDeck) && savedDeck.length === 8 && savedDeck.every(k => CARDS[k])) {
            userDeck = savedDeck;
            // Recalculate collection based on saved deck
            collection = allKeys.filter(k => !userDeck.includes(k));
        }
    } catch(e) { console.log("Save load error", e); }
}

let selectedDeckSlot = -1; let selectedCollectionSlot = -1;
let G = null;
let currentDifficulty = 'medium';

const DIFFICULTY_SETTINGS = {
    easy: { elixirMult: 0.7, react: 4.0 },
    medium: { elixirMult: 1.0, react: 2.5 },
    hard: { elixirMult: 1.4, react: 1.0 }
};

function saveData() {
    localStorage.setItem('clashDeck', JSON.stringify(userDeck));
}

function resizeGame() {
    const wrapper = document.getElementById('game-wrapper');
    const TARGET_RATIO = 540 / 960;
    const isDesktop = window.innerWidth > 600 && window.innerWidth > window.innerHeight;
    let availW = window.innerWidth, availH = window.innerHeight;
    if(isDesktop) { availH = window.innerHeight * 0.95; availW = window.innerWidth * 0.95; }
    let finalW, finalH;
    if (availW / availH > TARGET_RATIO) { finalH = availH; finalW = finalH * TARGET_RATIO; } 
    else { finalW = availW; finalH = finalW / TARGET_RATIO; }
    wrapper.style.width = finalW + 'px'; wrapper.style.height = finalH + 'px';
    CANVAS.width = 540; CANVAS.height = 960;
}
window.addEventListener('resize', resizeGame);
window.onload = () => { resizeGame(); sortAndRender(); updateAvgElixir(); };

function setDifficulty(level) {
    currentDifficulty = level;
    document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('btn-' + level).classList.add('active');
}

function updateAvgElixir() {
    let total = 0; userDeck.forEach(k => total += CARDS[k].cost);
    document.getElementById('avg-elixir').innerText = "Avg: " + (total/8).toFixed(1);
}

function switchTab(name, el) {
    document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.getElementById(name + '-view').classList.add('active');
    el.classList.add('active');
    if(name === 'deck') sortAndRender();
}

function sortAndRender() {
    let criteria = document.getElementById('sort-select').value;
    
    collection.sort((a,b) => {
        let cA = CARDS[a], cB = CARDS[b];
        if (criteria === 'elixir') return cA.cost - cB.cost;
        if (criteria === 'name') return cA.name.localeCompare(cB.name);
        if (criteria === 'rarity') {
            const rMap = { common: 1, rare: 2, epic: 3, legendary: 4 };
            return rMap[cA.rarity] - rMap[cB.rarity];
        }
        return 0;
    });
    
    renderDeckMenu();
}

function renderDeckMenu() {
    const deckGrid = document.getElementById('deck-grid');
    const colGrid = document.getElementById('collection-grid');
    deckGrid.innerHTML = ''; colGrid.innerHTML = '';
    
    userDeck.forEach((key, i) => {
        let div = createMenuCard(key);
        if(selectedDeckSlot === i) div.classList.add('selected');
        div.onclick = () => handleDeckClick(i, 'deck');
        deckGrid.appendChild(div);
    });

    collection.forEach((key, i) => {
        let div = createMenuCard(key);
        if(selectedCollectionSlot === i) div.classList.add('selected');
        div.onclick = () => handleDeckClick(i, 'collection');
        colGrid.appendChild(div);
    });
}

function createMenuCard(key) {
    let s = CARDS[key];
    let div = document.createElement('div');
    div.className = `real-card ${s.rarity}`;
    div.innerHTML = `
        <div class="elixir-drop"><span>${s.cost}</span></div>
        <img src="${SPRITES[s.sprite].src}">
        <div class="card-name-tag">${s.name}</div>
    `;
    return div;
}

function handleDeckClick(idx, type) {
    if (type === 'deck') {
        if (selectedCollectionSlot !== -1) {
            let temp = userDeck[idx]; userDeck[idx] = collection[selectedCollectionSlot]; collection[selectedCollectionSlot] = temp;
            selectedCollectionSlot = -1; selectedDeckSlot = -1; 
            saveData(); updateAvgElixir(); sortAndRender();
        } else if (selectedDeckSlot === idx) selectedDeckSlot = -1; else selectedDeckSlot = idx;
    } else {
        if (selectedDeckSlot !== -1) {
            let temp = collection[idx]; collection[idx] = userDeck[selectedDeckSlot]; userDeck[selectedDeckSlot] = temp;
            selectedDeckSlot = -1; selectedCollectionSlot = -1; 
            saveData(); updateAvgElixir(); sortAndRender();
        } else if (selectedCollectionSlot === idx) selectedCollectionSlot = -1; else selectedCollectionSlot = idx;
    }
    renderDeckMenu();
}

function startGame() {
    document.getElementById('menu-layer').style.display = 'none';
    document.getElementById('game-ui-layer').style.display = 'flex'; 
    document.getElementById('end-screen').style.display = 'none';
    resizeGame();
    G = new Game(userDeck, currentDifficulty);
}

function returnToMenu() {
    G = null;
    document.getElementById('end-screen').style.display = 'none';
    document.getElementById('game-ui-layer').style.display = 'none';
    document.getElementById('menu-layer').style.display = 'flex';
}

class Game {
    constructor(deck, diff) {
        this.t = 0; this.dt = 0.016;
        this.entities = []; this.projectiles = [];
        this.elixir = 5; this.maxElixir = 10;
        this.botElixir = 5; 
        
        this.diffSettings = DIFFICULTY_SETTINGS[diff];
        this.botNextMove = this.diffSettings.react; 

        this.timeLeft = CONSTANTS.GAME_DURATION;
        this.isOvertime = false; this.doubleElixir = false; this.gameOver = false;
        
        this.myDeck = [...deck];
        this.hand = this.myDeck.slice(0, 4);
        this.queue = this.myDeck.slice(4);
        this.botDeck = Object.keys(CARDS); 
        this.input = { cardIdx: -1, isDragging: false, x: 0, y: 0, valid: false };

        this.spawnTower('blue', CONSTANTS.LANE_LEFT, 610, 2536, false, 'left');
        this.spawnTower('blue', CONSTANTS.LANE_RIGHT, 610, 2536, false, 'right');
        this.spawnTower('blue', CONSTANTS.CENTER_X, 700, 4008, true, 'center'); 
        this.spawnTower('red', CONSTANTS.LANE_LEFT, 170, 2536, false, 'left');
        this.spawnTower('red', CONSTANTS.LANE_RIGHT, 170, 2536, false, 'right');
        this.spawnTower('red', CONSTANTS.CENTER_X, 80, 4008, true, 'center'); 
        
        setTimeout(() => renderHand(), 10);
    }

    spawnTower(team, x, y, hp, isKing, lane) {
        let t = new Entity(team, 'tower', x, y);
        t.maxHp = hp; t.hp = hp; t.dmg = 90; t.range = 7.5 * CONSTANTS.TILE_SIZE; 
        t.spd = 0; t.hitSpeed = 0.8; t.radius = 35; t.isBuilding = true; t.isKing = isKing; t.lane = lane; t.active = !isKing; 
        t.canTargetAir = true; 
        this.entities.push(t);
    }

    checkDeployValidity(x, y) {
        if (y > CONSTANTS.DOCK_Y) return false;
        if (y > CONSTANTS.BASE_DEPLOY) return true;
        let redLeftAlive = this.entities.some(e => e.team === 'red' && e.lane === 'left' && e.isBuilding);
        let redRightAlive = this.entities.some(e => e.team === 'red' && e.lane === 'right' && e.isBuilding);
        if (!redLeftAlive && x < CONSTANTS.CENTER_X && y > CONSTANTS.POCKET_Y) return true;
        if (!redRightAlive && x > CONSTANTS.CENTER_X && y > CONSTANTS.POCKET_Y) return true;
        return false;
    }

    handleMove(e) {
        const rect = CANVAS.getBoundingClientRect();
        this.input.x = (e.clientX - rect.left) * (CANVAS.width / rect.width);
        this.input.y = (e.clientY - rect.top) * (CANVAS.height / rect.height);
        if(this.input.cardIdx !== -1) this.input.valid = this.checkDeployValidity(this.input.x, this.input.y);
    }

    handleUp(e) {
        if(this.input.isDragging) {
            if(this.input.valid) this.deployCard(this.input.cardIdx, this.input.x, this.input.y);
            this.input.isDragging = false;
            let cardEl = document.getElementById('card-' + this.input.cardIdx);
            if (cardEl) cardEl.classList.remove('dragging');
            renderHand(); 
        }
    }

    handleDown(e) {
        if(this.input.cardIdx !== -1 && !this.input.isDragging) {
            if(this.input.valid) this.deployCard(this.input.cardIdx, this.input.x, this.input.y);
            else { this.input.cardIdx = -1; renderHand(); }
        }
    }

    selectCard(idx) {
        let key = this.hand[idx];
        if(this.elixir >= CARDS[key].cost) {
            if (this.input.cardIdx === idx && !this.input.isDragging) {
                this.input.cardIdx = -1;
            } else {
                this.input.cardIdx = idx;
                this.input.isDragging = true;
                this.input.valid = false;
                document.getElementById('card-'+idx).classList.add('dragging');
            }
            renderHand();
        }
    }

    deployCard(idx, x, y) {
        let key = this.hand[idx];
        let stats = CARDS[key];
        if(this.elixir >= stats.cost) {
            this.elixir -= stats.cost;
            for(let i=0; i<stats.count; i++) {
                let ox = (i*20) - (stats.count-1)*10;
                let u = new Entity('blue', key, x + ox, y);
                this.applyStats(u, stats);
                this.entities.push(u);
            }
            let nextCard = this.queue.shift(); 
            this.queue.push(key);              
            this.hand[idx] = nextCard;         
            this.input.cardIdx = -1;
            this.input.isDragging = false;
            renderHand(); 
        }
    }

    applyStats(entity, stats) {
        entity.maxHp = stats.hp; entity.hp = stats.hp; entity.dmg = stats.dmg; entity.range = stats.rng;
        entity.spd = stats.spd; entity.hitSpeed = stats.hit; entity.sprite = stats.sprite; entity.targetPref = stats.targetPref; 
        entity.isFlying = stats.flying || false;
        entity.canTargetAir = stats.targetsAir !== undefined ? stats.targetsAir : true; 
        entity.splash = stats.splash || false;
        entity.splashRadius = stats.splashRadius || 0;
        entity.slows = stats.slows || false;
        entity.shrapnel = stats.shrapnel || false;
        entity.charge = stats.charge || false;
        entity.jump = stats.jump || false;
        entity.spawner = stats.spawner || false;
        entity.deathSpawn = stats.deathSpawn || false;
    }

    update() {
        if(this.gameOver) return;
        this.t += this.dt; this.timeLeft -= this.dt;
        if (!this.doubleElixir && (this.timeLeft <= CONSTANTS.DOUBLE_ELIXIR_TIME || this.isOvertime)) { this.doubleElixir = true; showStatus("x2 Elixir!"); }
        
        let rate = this.doubleElixir ? 1.4 : 2.8; 
        let regen = this.dt / rate;
        
        if(this.elixir < 10) this.elixir += regen; 
        if(this.botElixir < 10) this.botElixir += (regen * this.diffSettings.elixirMult);

        if (this.timeLeft <= 0) {
            if (this.isOvertime) this.checkWinCondition(true); 
            else if (this.checkWinCondition(false) === false) {
                this.isOvertime = true; this.timeLeft = CONSTANTS.OVERTIME_DURATION; showStatus("Sudden Death!");
            }
        }

        ['blue', 'red'].forEach(team => {
            let king = this.entities.find(e => e.team === team && e.isKing);
            if(king && !king.active) {
                if(king.hp < king.maxHp) king.active = true;
                let princessCount = this.entities.filter(e => e.team === team && e.isBuilding && !e.isKing).length;
                if(princessCount < 2) king.active = true;
            }
        });

        if(this.t > this.botNextMove) {
            let k = this.botDeck[Math.floor(Math.random()*this.botDeck.length)];
            let stats = CARDS[k];
            if(this.botElixir >= stats.cost) {
                this.botElixir -= stats.cost;
                let lane = Math.random() > 0.5 ? CONSTANTS.LANE_LEFT : CONSTANTS.LANE_RIGHT;
                let u = new Entity('red', k, lane, 250); 
                this.applyStats(u, stats); this.entities.push(u);
                this.botNextMove = this.t + this.diffSettings.react + Math.random();
            } else { this.botNextMove = this.t + 0.5; }
        }

        this.entities.sort((a,b) => a.y - b.y);
        this.entities.forEach(e => e.update(this));
        
        // Remove dead
        let dead = this.entities.filter(e => e.hp <= 0);
        dead.forEach(e => {
            if(e.isBuilding && e.isKing) this.end(e.team === 'red' ? "BLUE WINS!" : "RED WINS!");
            else if(e.isBuilding && this.isOvertime) this.end(e.team === 'red' ? "BLUE WINS!" : "RED WINS!");

            // GOLEM DEATH
            if(e.deathSpawn && e.sprite === 'golem') {
                 for(let i=0; i<2; i++) {
                     let g = new Entity(e.team, 'golemite', e.x + (i*20-10), e.y);
                     g.maxHp = 1000; g.hp = 1000; g.dmg = 70; g.spd = 30; g.radius = 15; g.hitSpeed = 1.5;
                     g.sprite = 'golem'; 
                     this.entities.push(g);
                 }
                 this.projectiles.push(new Projectile(e.x, e.y, null, 'bomb', e.team, true, 100)); 
            }
        });

        this.entities = this.entities.filter(e => e.hp > 0);
        this.projectiles.forEach(p => p.update(this));
        this.projectiles = this.projectiles.filter(p => p.active);
    }

    checkWinCondition(forceEnd) {
        let blueTowers = this.entities.filter(e => e.team === 'blue' && e.isBuilding).length;
        let redTowers = this.entities.filter(e => e.team === 'red' && e.isBuilding).length;
        if (blueTowers > redTowers) { this.end("BLUE WINS!"); return true; }
        else if (redTowers > blueTowers) { this.end("RED WINS!"); return true; }
        else { if (forceEnd) this.end("DRAW!"); return false; }
    }

    end(res) {
        if(this.gameOver) return;
        this.gameOver = true;
        document.getElementById('end-screen').style.display = 'flex';
        document.getElementById('end-msg').innerText = res;
    }

    draw() {
        CTX.fillStyle = '#4c9b56'; CTX.fillRect(0,0,CANVAS.width,CANVAS.height);
        CTX.fillStyle = '#56a760';
        for(let r=0; r<32; r++) for(let c=0; c<18; c++) if((r+c)%2===0) CTX.fillRect(c*30, r*30, 30, 30);

        CTX.strokeStyle = 'rgba(255, 255, 255, 0.3)'; CTX.lineWidth = 2; CTX.setLineDash([10, 10]); CTX.beginPath();
        let redLeftAlive = this.entities.some(e => e.team === 'red' && e.lane === 'left' && e.isBuilding);
        let redRightAlive = this.entities.some(e => e.team === 'red' && e.lane === 'right' && e.isBuilding);
        let leftY = redLeftAlive ? CONSTANTS.BASE_DEPLOY : CONSTANTS.POCKET_Y;
        CTX.moveTo(0, leftY); CTX.lineTo(CONSTANTS.CENTER_X, leftY); CTX.lineTo(CONSTANTS.CENTER_X, CONSTANTS.BASE_DEPLOY);
        let rightY = redRightAlive ? CONSTANTS.BASE_DEPLOY : CONSTANTS.POCKET_Y;
        CTX.moveTo(CONSTANTS.CENTER_X, rightY); CTX.lineTo(540, rightY);
        if (!redRightAlive) { CTX.moveTo(CONSTANTS.CENTER_X, rightY); CTX.lineTo(CONSTANTS.CENTER_X, CONSTANTS.BASE_DEPLOY); }
        CTX.stroke(); CTX.setLineDash([]);

        CTX.fillStyle = '#4da6ff'; CTX.fillRect(0, CONSTANTS.RIVER_Y - 20, 540, 40);
        CTX.fillStyle = '#8b5a2b';
        CTX.fillRect(CONSTANTS.LANE_LEFT - 30, CONSTANTS.BRIDGE_Y - 30, 60, 60);
        CTX.fillRect(CONSTANTS.LANE_RIGHT - 30, CONSTANTS.BRIDGE_Y - 30, 60, 60);

        this.entities.forEach(e => e.draw(CTX));
        this.projectiles.forEach(p => p.draw(CTX));

        if(this.input.cardIdx !== -1) {
            if (this.input.isDragging || this.input.y < CONSTANTS.DOCK_Y) {
                let k = this.hand[this.input.cardIdx];
                let s = CARDS[k];
                CTX.beginPath(); CTX.arc(this.input.x, this.input.y, s.rng, 0, 6.28);
                CTX.fillStyle = this.input.valid ? 'rgba(255, 255, 255, 0.2)' : 'rgba(255, 0, 0, 0.2)';
                CTX.fill(); CTX.strokeStyle = this.input.valid ? '#fff' : '#f00'; CTX.lineWidth = 2; CTX.stroke();
                CTX.save(); CTX.globalAlpha = 0.7;
                let img = SPRITES[s.sprite]; let w = 50, h = 50; 
                CTX.drawImage(img, this.input.x - w/2, this.input.y - h/2, w, h);
                CTX.restore();
            }
        }
    }
}

class Entity {
    constructor(team, type, x, y) {
        this.team = team; this.type = type; this.x = x; this.y = y;
        this.radius = 20; this.state = 'idle'; this.target = null; this.lastAttack = 0;
        this.sprite = 'knight'; this.animOffset = 0; this.targetPref = 'any';
        this.retargetTimer = 0; this.isBuilding = false; this.isKing = false; 
        this.active = true; this.isFlying = false;
        
        // Mechanics
        this.canTargetAir = true; 
        this.splash = false; this.splashRadius = 0;
        this.slows = false; this.slowTimer = 0;
        this.shrapnel = false;
        this.charge = false; this.chargeTimer = 0; this.isCharging = false;
        this.jump = false; this.jumpTimer = 0; this.isJumping = false; this.jumpTarget = null;
        this.spawner = false; this.spawnTimer = 0;
        this.deathSpawn = false;
    }

    update(game) {
        this.slowTimer -= game.dt;
        this.retargetTimer -= game.dt;
        if(this.spawner) {
            this.spawnTimer += game.dt;
            if(this.spawnTimer > 7.0) {
                this.spawnTimer = 0;
                for(let i=0; i<3; i++) {
                    let s = new Entity(this.team, 'skeleton', this.x + (Math.random()*40-20), this.y + (Math.random()*40-20));
                    s.maxHp = 81; s.hp = 81; s.dmg = 81; s.spd = 80; s.hitSpeed = 1.0; s.radius = 10; s.sprite = 'skeletons';
                    s.canTargetAir = false;
                    game.entities.push(s);
                }
            }
        }

        if(this.isKing && !this.active) { this.target = null; return; }

        let currentSpd = this.slowTimer > 0 ? this.spd * 0.5 : this.spd;
        if (this.isCharging) currentSpd *= 2.0;

        if (this.jump && !this.isJumping) {
            let targets = game.entities.filter(e => e.team !== this.team && !e.isFlying); 
            for(let t of targets) {
                let d = Math.hypot(t.x - this.x, t.y - this.y);
                if (d > 3.5 * CONSTANTS.TILE_SIZE && d < 5 * CONSTANTS.TILE_SIZE) {
                    this.isJumping = true; this.jumpTarget = t; this.jumpTimer = 0;
                    break; 
                }
            }
        }

        if (this.isJumping) {
            this.jumpTimer += game.dt;
            if (this.jumpTarget && this.jumpTarget.hp > 0) {
                let dx = this.jumpTarget.x - this.x; let dy = this.jumpTarget.y - this.y;
                let dist = Math.hypot(dx, dy);
                if (dist < 10 || this.jumpTimer > 1.0) { 
                    this.isJumping = false; 
                    game.entities.forEach(ent => {
                        if (ent.team !== this.team && Math.hypot(ent.x - this.x, ent.y - this.y) < this.splashRadius + ent.radius) {
                             ent.hp -= (this.dmg * 2); 
                        }
                    });
                } else {
                    this.x += (dx/dist) * 300 * game.dt; 
                    this.y += (dy/dist) * 300 * game.dt;
                }
            } else { this.isJumping = false; }
            return; 
        }

        if (!this.target || this.target.hp <= 0 || (this.retargetTimer < 0 && this.target.isBuilding && this.targetPref === 'any')) {
            this.target = this.findBestTarget(game.entities);
            this.retargetTimer = 0.5;
        }

        if(this.target) {
            let interactDist = this.range + this.target.radius;
            let dist = Math.hypot(this.target.x - this.x, this.target.y - this.y);

            if(dist <= interactDist) {
                if (this.charge) { this.isCharging = false; this.chargeTimer = 0; } 

                if(game.t - this.lastAttack > this.hitSpeed) {
                    this.lastAttack = game.t;
                    if(this.range > 50) {
                        let pType = 'arrow';
                        if(this.sprite === 'bomber') pType = 'bomb';
                        if(this.sprite === 'icewizard') pType = 'ice';
                        if(this.sprite === 'wizard') pType = 'magic';
                        if(this.sprite === 'firecracker') pType = 'rocket';
                        game.projectiles.push(new Projectile(this.x, this.y, this.target, pType, this.team, this.splash, this.splashRadius, this.slows, this.shrapnel));
                    } else {
                        let dmg = this.dmg;
                        if (this.charge && this.chargeTimer > 2.0) dmg *= 2; 

                        if (this.splash) {
                             game.entities.forEach(ent => {
                                 if (ent.team !== this.team && Math.hypot(ent.x - this.x, ent.y - this.y) < this.splashRadius + ent.radius) {
                                     ent.hp -= dmg;
                                 }
                             });
                        } else {
                             this.target.hp -= dmg;
                        }
                    }
                }
            } else {
                if (this.charge) {
                    this.chargeTimer += game.dt;
                    if (this.chargeTimer > 2.0) this.isCharging = true;
                }

                if (!this.isBuilding) {
                    let moveTarget = {x: this.target.x, y: this.target.y};
                    if (!this.isFlying) {
                        let riverY = CONSTANTS.RIVER_Y;
                        let onBottom = this.y > riverY;
                        let targetOnBottom = this.target.y > riverY;
                        if (onBottom !== targetOnBottom) {
                            let distLeft = Math.abs(this.x - CONSTANTS.LANE_LEFT);
                            let distRight = Math.abs(this.x - CONSTANTS.LANE_RIGHT);
                            let bridgeX = distLeft < distRight ? CONSTANTS.LANE_LEFT : CONSTANTS.LANE_RIGHT;
                            if (Math.abs(this.x - bridgeX) > 10) {
                                moveTarget.x = bridgeX;
                                moveTarget.y = CONSTANTS.BRIDGE_Y; 
                            }
                        }
                    }
                    let mdx = moveTarget.x - this.x;
                    let mdy = moveTarget.y - this.y;
                    let angle = Math.atan2(mdy, mdx);
                    this.x += Math.cos(angle) * currentSpd * game.dt;
                    this.y += Math.sin(angle) * currentSpd * game.dt;
                    this.animOffset += 0.2; 
                }
            }
        } else {
            if(!this.isBuilding) {
                 let forwardY = this.team === 'blue' ? 0 : 960;
                 if (Math.abs(this.y - forwardY) > 10) {
                     this.y += (this.team==='blue'?-1:1) * currentSpd * game.dt;
                 }
            }
        }
    }

    findBestTarget(entities) {
        let min = Infinity;
        let c = null;
        entities.forEach(e => {
            if(e.team === this.team) return;
            if(this.targetPref === 'building' && !e.isBuilding) return;
            if (e.isFlying && !this.canTargetAir) return;
            
            let d = Math.hypot(e.x - this.x, e.y - this.y);
            if(d < min) { min = d; c = e; }
        });
        return c;
    }

    draw(ctx) {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(this.x, this.y + 5, this.radius, this.radius/2, 0, 0, 6.28); ctx.fill();

        let img = SPRITES[this.sprite] || SPRITES['knight'];
        let w = this.radius * 2.5; let h = this.radius * 2.5;
        let bob = this.isBuilding ? 0 : Math.sin(this.animOffset) * 2;
        
        ctx.save();
        if (this.slowTimer > 0) ctx.filter = 'hue-rotate(180deg) brightness(1.2)'; 
        if (this.isCharging) ctx.filter = 'sepia(1) saturate(5)'; 

        ctx.fillStyle = this.team === 'blue' ? '#36f' : '#f33';
        if(this.isBuilding) {
             ctx.fillRect(this.x-10, this.y-50, 20, 20); 
             if(this.isKing && !this.active) {
                ctx.fillStyle = '#fff'; ctx.font = 'bold 20px Arial'; ctx.fillText('Zzz', this.x - 15, this.y - 60);
             }
        } else {
             ctx.beginPath(); ctx.arc(this.x, this.y-10+bob, 15, 0, 6.28); ctx.fill();
        }
        ctx.drawImage(img, this.x - w/2, this.y - h/1.2 + bob, w, h);
        
        if(!this.isBuilding && CARDS[this.sprite]) {
            let name = CARDS[this.sprite].name;
            ctx.font = "bold 10px Arial"; ctx.textAlign = "center"; ctx.lineWidth = 2.5;
            ctx.strokeStyle = "black"; ctx.fillStyle = "white";
            ctx.strokeText(name, this.x, this.y - h/1.3 + bob);
            ctx.fillText(name, this.x, this.y - h/1.3 + bob);
        }

        ctx.restore();

        // HP BAR - FIXED POSITION
        let pct = Math.max(0, this.hp / this.maxHp);
        let barY = this.y - h - 10;
        
        // Force bar below unit if it's too high up (e.g. Enemy King Tower)
        if (barY < 20) barY = this.y + 20;

        ctx.fillStyle = '#333'; ctx.fillRect(this.x - 20, barY, 40, 6);
        ctx.fillStyle = this.team === 'blue' ? '#6f6' : '#f66'; ctx.fillRect(this.x - 20, barY, 40 * pct, 6);
    }
}

class Projectile {
    constructor(x, y, target, type, team, splash, radius, slows, shrapnel) {
        this.x = x; this.y = y; this.target = target;
        this.active = true; this.speed = 350;
        this.type = type; 
        this.team = team;
        this.splash = splash || false;
        this.radius = radius || 0;
        this.slows = slows || false;
        this.shrapnel = shrapnel || false;
        this.vx = 0; this.vy = 0; 
    }
    
    update(game) {
        if (this.type === 'shrapnel') {
            this.x += this.vx * game.dt;
            this.y += this.vy * game.dt;
            if (this.active) { 
                game.entities.forEach(ent => {
                    if (ent.team !== this.team && Math.hypot(ent.x - this.x, ent.y - this.y) < 20) {
                        ent.hp -= 50; this.active = false;
                    }
                });
            }
            if (Math.random() < 0.05) this.active = false; 
            return;
        }

        if(!this.target || this.target.hp <= 0) { this.active = false; return; }
        let dx = this.target.x - this.x; let dy = this.target.y - this.y;
        
        if(Math.hypot(dx, dy) < 10) { 
            this.active = false;
            
            if (this.splash) {
                 game.entities.forEach(ent => {
                     if (ent.team !== this.team && Math.hypot(ent.x - this.x, ent.y - this.y) < this.radius + ent.radius) {
                         ent.hp -= (this.target === ent ? 0 : 70); 
                         if (ent === this.target) ent.hp -= 70; 
                         if (this.slows) ent.slowTimer = 2.0;
                     }
                 });
            } else {
                 this.target.hp -= 70;
                 if (this.slows) this.target.slowTimer = 2.0;
            }

            if (this.shrapnel) {
                let baseAngle = Math.atan2(dy, dx);
                for(let i=-1; i<=1; i++) {
                    let p = new Projectile(this.x, this.y, null, 'shrapnel', this.team);
                    let angle = baseAngle + i * 0.4 + Math.PI; 
                    p.vx = Math.cos(angle) * 400;
                    p.vy = Math.sin(angle) * 400;
                    game.projectiles.push(p);
                }
            }

        } else {
            let angle = Math.atan2(dy, dx);
            this.x += Math.cos(angle) * this.speed * game.dt;
            this.y += Math.sin(angle) * this.speed * game.dt;
        }
    }

    draw(ctx) { 
        if (this.type === 'arrow') { ctx.drawImage(SPRITES['arrow'], this.x-10, this.y-10, 20, 20); } 
        else if (this.type === 'bomb') { ctx.beginPath(); ctx.arc(this.x, this.y, 6, 0, 6.28); ctx.fillStyle = '#333'; ctx.fill(); } 
        else if (this.type === 'magic') { ctx.beginPath(); ctx.arc(this.x, this.y, 6, 0, 6.28); ctx.fillStyle = '#f0f'; ctx.fill(); } 
        else if (this.type === 'ice') { ctx.beginPath(); ctx.arc(this.x, this.y, 6, 0, 6.28); ctx.fillStyle = '#0ff'; ctx.fill(); } 
        else if (this.type === 'rocket') { ctx.fillStyle = 'orange'; ctx.fillRect(this.x-3, this.y-3, 6, 15); } 
        else if (this.type === 'shrapnel') { ctx.fillStyle = '#fa0'; ctx.fillRect(this.x-2, this.y-2, 4, 4); }
    }
}

// Global Handlers
window.addEventListener('pointermove', (e) => { if(G) G.handleMove(e); });
window.addEventListener('pointerup', (e) => { if(G) G.handleUp(e); });
CANVAS.addEventListener('pointerdown', (e) => { if(G) G.handleDown(e); });

function showStatus(text) {
    let el = document.getElementById('game-status');
    el.innerText = text; el.style.display = 'block';
    setTimeout(() => { el.style.display = 'none'; }, 3000);
}

function renderHand() {
    let dock = document.getElementById('card-dock');
    dock.innerHTML = '';
    if(!G) return;
    G.hand.forEach((k, i) => {
        let div = document.createElement('div');
        div.className = 'game-card ' + CARDS[k].rarity + (G.input.cardIdx === i ? ' active' : '');
        div.id = 'card-' + i;
        div.innerHTML = `<div class="cost">${CARDS[k].cost}</div><img src="${SPRITES[CARDS[k].sprite].src}"><div class="game-card-name">${CARDS[k].name}</div>`;
        div.onpointerdown = (e) => { G.selectCard(i); e.preventDefault(); };
        dock.appendChild(div);
    });
}

function updateUI() {
    if(!G) return;
    document.getElementById('elixir-fill').style.width = (G.elixir*10)+'%';
    document.getElementById('elixir-text').innerText = Math.floor(G.elixir);
    let m = Math.floor(Math.max(0, G.timeLeft) / 60);
    let s = Math.floor(Math.max(0, G.timeLeft) % 60);
    document.getElementById('time-display').innerText = `${m}:${s < 10 ? '0' : ''}${s}`;
    if (G.isOvertime) document.getElementById('time-display').style.color = '#f00';
    G.hand.forEach((k, i) => {
        let c = document.getElementById('card-' + i);
        if(c) {
             if(G.elixir < CARDS[k].cost) c.classList.add('disabled');
             else c.classList.remove('disabled');
        }
    });
}

function loop() {
    if(G) { G.update(); G.draw(); updateUI(); }
    requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
